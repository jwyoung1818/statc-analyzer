WARNING: unrecognized file type unrecognized_file_type, path: ./app/views/home/rss.erb
controller: filters
action: update
def update
    tags_param = params[:tags]
    new_tags = tags_param.blank? ? [] :
      Tag.active.where(:tag => tags_param).to_a
    new_tags.keep_if {|t| t.valid_for? @user }

    if @user
      @user.tag_filter_tags = new_tags
    else
      cookies.permanent[TAG_FILTER_COOKIE] = new_tags.map(&:tag).join(",")
    end

    flash[:success] = "Your filters have been updated."

    redirect_to filters_path
  end
----------------------
controller: filters
action: index
def index
    @cur_url = "/filters"
    @title = "Tag Filters"

    @tags = Tag.active.all_with_story_counts_for(@user)

    if @user
      @filtered_tags = @user.tag_filter_tags.to_a
    else
      @filtered_tags = tags_filtered_by_cookie.to_a
    end
  end
----------------------
controller: users
action: unban
def unban
    buser = User.where(:username => params[:username]).first
    if !buser
      flash[:error] = "Invalid user."
      return redirect_to "/"
    end

    buser.unban_by_user!(@user)

    flash[:success] = "User has been unbanned."
    return redirect_to user_path(:user => buser.username)
  end
----------------------
controller: users
action: ban
def ban
    buser = User.where(:username => params[:username]).first
    if !buser
      flash[:error] = "Invalid user."
      return redirect_to "/"
    end

    if !params[:reason].present?
      flash[:error] = "You must give a reason for the ban."
      return redirect_to user_path(:user => buser.username)
    end

    buser.ban_by_user_for_reason!(@user, params[:reason])

    flash[:success] = "User has been banned."
    return redirect_to user_path(:user => buser.username)
  end
----------------------
controller: users
action: invite
def invite
    @title = "Pass Along an Invitation"
  end
----------------------
controller: users
action: tree
def tree
    @title = "Users"

    if params[:by].to_s == "karma"
      @users = User.order("karma DESC, id ASC").to_a
      @user_count = @users.length
      @title << " By Karma"
       @title 
 @user_count 
 @users.each do |user| 
 user.username 
 if !user.is_active? 
 elsif user.is_new? 
 end 
 user.username 
 if user.is_admin? 
 else 
 user.karma 
 if user.is_moderator? 
 end 
 end 
 end 

    elsif params[:moderators]
      @users = User.where("is_admin = 1 OR is_moderator = 1").
        order("id ASC").to_a
      @user_count = @users.length
      @title = "Moderators and Administrators"
       @title 
 @user_count 
 @users.each do |user| 
 user.username 
 if !user.is_active? 
 elsif user.is_new? 
 end 
 user.username 
 if user.is_admin? 
 else 
 user.karma 
 if user.is_moderator? 
 end 
 end 
 end 

    else
      users = User.order("id DESC").to_a
      @user_count = users.length
      @users_by_parent = users.group_by(&:invited_by_user_id)
      @newest = User.order("id DESC").limit(10)
    end
  end
----------------------
controller: users
action: show
def show
    @showing_user = User.where(:username => params[:username]).first!
    @title = "User #{@showing_user.username}"

    respond_to do |format|
      format.html {  if !@showing_user.is_active? 
 elsif @showing_user.is_new? 
 else 
 end 
 @showing_user.username 
 if @user && @showing_user.is_active? 
 @showing_user.username 
 end 
 if @showing_user.is_active? 
 @showing_user.avatar_url(100) 
 @showing_user.avatar_url(100) 
 @showing_user.avatar_url(200) 
 end 
 @showing_user.is_banned? ? raw("style=\"color: red;\"") : "" 
 if @showing_user.is_banned? 
 elsif !@showing_user.is_active? 
 else 
 end 
 @showing_user.is_admin? ? "administrator" :
      (@showing_user.is_moderator? ? "moderator" : "user") 
 time_ago_in_words_label(@showing_user.created_at) 
 if @showing_user.invited_by_user 
 link_to @showing_user.invited_by_user.try(:username),
        @showing_user.invited_by_user 
 end 
 if @showing_user.is_banned? 
 time_ago_in_words_label(@showing_user.banned_at) 
 if @showing_user.banned_by_user 
 link_to @showing_user.banned_by_user.try(:username),
          @showing_user.banned_by_user 
 @showing_user.banned_reason 
 end 
 end 
 if @showing_user.hats.any? 
 @showing_user.hats.each do |hat| 
 hat.to_html_label 
 end 
 end 
 if @showing_user.deleted_at? 
 time_ago_in_words_label(@showing_user.deleted_at) 
 end 
 if !@showing_user.is_admin? 
 @showing_user.karma 

        number_with_precision(@showing_user.average_karma, :precision => 2) 
 end 
 tag = @showing_user.most_common_story_tag 
 @showing_user.username 

      @showing_user.stories_submitted_count 
 tag ? ", " : "" 
 if tag 
 tag_path(tag.tag) 
 tag.css_class 
 tag.description 

        tag.tag 
 end 
 @showing_user.username 

      @showing_user.comments_posted_count 
 if @showing_user.is_active? 
 if @showing_user.about.present? 
 raw @showing_user.linkified_about 
 else 
 end 
 end 
 if @user && @user.is_admin? && !@showing_user.is_moderator? 
 @showing_user.email 
 @showing_user.votes_for_others.limit(10).each do |v| 
 if v.vote == 1 
 else 
 v.vote 
 if v.comment_id 
 Vote::COMMENT_REASONS[v.reason] 
 else 
 Vote::STORY_REASONS[v.reason] 
 end 
 end 
 if v.comment_id 
 v.comment.short_id_url 
 v.comment.user.try(:username) 
 
            v.comment.user.try(:username) 
 v.story.short_id_url 
 v.story.title 
 elsif v.story_id && !v.comment_id 
 v.story.short_id_url 
 v.story.title 
 v.story.user.try(:username) 

            v.story.user.try(:username) 
 end 
 end 
 if @user.is_banned? 
 form_tag user_unban_path, :method => :post do 
 submit_tag "Unban User" 
 end 
 else 
 form_tag user_ban_path, :method => :post do 
 label_tag :reason, "Reason:", :class => "required" 
 text_field_tag :reason, "", :size => 40 
 submit_tag "Ban User" 
 end 
 end 
 end 
 }
      format.json { render :json => @showing_user }
    end
  end
----------------------
controller: comments
action: find_comment
def find_comment
    comment = Comment.where(:short_id => params[:id]).first
    if @user && comment
      comment.current_vote = Vote.where(:user_id => @user.id,
        :story_id => comment.story_id, :comment_id => comment.id).first
    end

    comment
  end
----------------------
controller: comments
action: preview(comment)
def preview(comment)
    comment.previewing = true
    comment.is_deleted = false # show normal preview for deleted comments

     comment.short_id if comment.persisted? 
 form_for comment,
:html => { :id => "edit_comment_#{comment.short_id}" } do |f| 
 if comment.errors.any? 
 errors_for comment 
 end 
 hidden_field_tag "story_id", comment.story.short_id 
 if comment.parent_comment 
 hidden_field_tag "parent_comment_short_id",
      comment.parent_comment.short_id 
 end 
 text_area_tag "comment", comment.comment, :rows => 5,
      :style => "width: 100%;", :autocomplete => "off", :disabled => !@user,
      :placeholder => (@user ? "" : "You must be logged in to leave a comment.")
      
 if @user 
 end 
 button_tag "#{comment.new_record?? "Post" : "Update"}",
        :class => "comment-post", :type => "button",
        :disabled => !@user 
 button_tag "Preview", :class => "comment-preview",
        :type => "button", :disabled => !@user 
 if comment.persisted? || comment.parent_comment_id 
 button_tag "Cancel", :class => "comment-cancel",
          :type => "button" 
 end 
 if @user && @user.hats.any? 
 select_tag "hat_id",
          options_from_collection_for_select(@user.hats, "id", "hat",
          comment.hat_id), :include_blank => true 
 end 
 if @user 
  if defined?(allow_images) && allow_images 
 end 
 
 end 
 end 
 if defined?(show_comment) && show_comment.valid? 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 end 

  end
----------------------
controller: comments
action: threads
def threads
    if params[:user]
      @showing_user = User.where(:username => params[:user]).first!
      @heading = @title = "Threads for #{@showing_user.username}"
      @cur_url = "/threads/#{@showing_user.username}"
    elsif !@user
      # TODO: show all recent threads
      return redirect_to "/login"
    else
      @showing_user = @user
      @heading = @title = "Your Threads"
      @cur_url = "/threads"
    end

    thread_ids = @showing_user.recent_threads(20,
      include_submitted_stories = !!(@user && @user.id == @showing_user.id))

    comments = Comment.where(
      :thread_id => thread_ids
    ).includes(
      :user, :story
    ).arrange_for_user(
      @showing_user
    )

    comments_by_thread_id = comments.group_by(&:thread_id)
    @threads = comments_by_thread_id.values_at(*thread_ids).compact

    if @user && (@showing_user.id == @user.id)
      @votes = Vote.comment_votes_by_user_for_story_hash(@user.id,
        comments.map(&:story_id).uniq)

      comments.each do |c|
        if @votes[c.id]
          c.current_vote = @votes[c.id]
        end
      end
    end

    # trim each thread to this user's first response
    # XXX: busted
    #@threads.each do |th|
    #  th.each do |c|
    #    if c.user_id == @user.id
    #      break
    #    else
    #      th.shift
    #    end
    #  end
    #end
  end
----------------------
controller: comments
action: index
def index
    @rss_link ||= { :title => "RSS 2.0 - Newest Comments",
      :href => "/comments.rss#{@user ? "?token=#{@user.rss_token}" : ""}" }

    @heading = @title = "Newest Comments"
    @cur_url = "/comments"

    @page = 1
    if params[:page].to_i > 0
      @page = params[:page].to_i
    end

    @comments = Comment.where(
      :is_deleted => false, :is_moderated => false
    ).order(
      "created_at DESC"
    ).offset(
      (@page - 1) * COMMENTS_PER_PAGE
    ).limit(
      COMMENTS_PER_PAGE
    ).includes(
      :user, :story
    )

    if @user
      @comments = @comments.where("story_id NOT IN (SELECT story_id FROM " <<
        "hidden_stories WHERE user_id = ?)", @user.id)

      @votes = Vote.comment_votes_by_user_for_comment_ids_hash(@user.id,
        @comments.map{|c| c.id })

      @comments.each do |c|
        if @votes[c.id]
          c.current_vote = @votes[c.id]
        end
      end
    end

    respond_to do |format|
      format.html {  @comments.each do |comment| 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 end 
 if @page && @page > 1 
 @page == 2 ? "" : "/page/#{@page - 1}" 
 @page - 1 
 end 
 if @comments.any? 
 if @page && @page > 1 
 end 
 @page + 1 
 @page + 1 
 end 
 }
      format.rss {
        if @user && params[:token].present?
          @title = "Private comments feed for #{@user.username}"
        end

         coder = HTMLEntities.new 
 Rails.application.name 
 @title.present? ?
      ": " + h(@title) : "" 
 @title 
 Rails.application.root_url 
 @comments.each do |comment| 
 raw coder.encode(comment.story.title, :decimal) 
 comment.url 
 comment.short_id_url 
 comment.user.username 
 comment.created_at.rfc2822 
 comment.url 
 raw coder.encode(comment.markeddown_comment,
          :decimal) 
 end 

      }
    end
  end
----------------------
controller: comments
action: downvote
def downvote
    if !(comment = find_comment)
      return render :text => "can't find comment", :status => 400
    end

    if !Vote::COMMENT_REASONS[params[:reason]]
      return render :text => "invalid reason", :status => 400
    end

    if !@user.can_downvote?(comment)
      return render :text => "not permitted to downvote", :status => 400
    end

    Vote.vote_thusly_on_story_or_comment_for_user_because(-1, comment.story_id,
      comment.id, @user.id, params[:reason])

    render :text => "ok"
  end
----------------------
controller: comments
action: upvote
def upvote
    if !(comment = find_comment)
      return render :text => "can't find comment", :status => 400
    end

    Vote.vote_thusly_on_story_or_comment_for_user_because(1, comment.story_id,
      comment.id, @user.id, params[:reason])

    render :text => "ok"
  end
----------------------
controller: comments
action: unvote
def unvote
    if !(comment = find_comment)
      return render :text => "can't find comment", :status => 400
    end

    Vote.vote_thusly_on_story_or_comment_for_user_because(0, comment.story_id,
      comment.id, @user.id, nil)

    render :text => "ok"
  end
----------------------
controller: comments
action: update
def update
    if !((comment = find_comment) && comment.is_editable_by_user?(@user))
      return render :text => "can't find comment", :status => 400
    end

    comment.comment = params[:comment]
    comment.hat_id = nil
    if params[:hat_id] && @user.hats.where(:id => params[:hat_id])
      comment.hat_id = params[:hat_id]
    end

    if params[:preview].blank? && comment.save
      votes = Vote.comment_votes_by_user_for_comment_ids_hash(@user.id,
        [comment.id])
      comment.current_vote = votes[comment.id]

       comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 

    else
      comment.current_vote = { :vote => 1 }

      preview comment
    end
  end
----------------------
controller: comments
action: undelete
def undelete
    if !((comment = find_comment) && comment.is_undeletable_by_user?(@user))
      return render :text => "can't find comment", :status => 400
    end

    comment.undelete_for_user(@user)

     comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 

  end
----------------------
controller: comments
action: delete
def delete
    if !((comment = find_comment) && comment.is_deletable_by_user?(@user))
      return render :text => "can't find comment", :status => 400
    end

    comment.delete_for_user(@user)

     comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 

  end
----------------------
controller: comments
action: reply
def reply
    if !(parent_comment = find_comment)
      return render :text => "can't find comment", :status => 400
    end

    comment = Comment.new
    comment.story = parent_comment.story
    comment.parent_comment = parent_comment

     comment.short_id if comment.persisted? 
 form_for comment,
:html => { :id => "edit_comment_#{comment.short_id}" } do |f| 
 if comment.errors.any? 
 errors_for comment 
 end 
 hidden_field_tag "story_id", comment.story.short_id 
 if comment.parent_comment 
 hidden_field_tag "parent_comment_short_id",
      comment.parent_comment.short_id 
 end 
 text_area_tag "comment", comment.comment, :rows => 5,
      :style => "width: 100%;", :autocomplete => "off", :disabled => !@user,
      :placeholder => (@user ? "" : "You must be logged in to leave a comment.")
      
 if @user 
 end 
 button_tag "#{comment.new_record?? "Post" : "Update"}",
        :class => "comment-post", :type => "button",
        :disabled => !@user 
 button_tag "Preview", :class => "comment-preview",
        :type => "button", :disabled => !@user 
 if comment.persisted? || comment.parent_comment_id 
 button_tag "Cancel", :class => "comment-cancel",
          :type => "button" 
 end 
 if @user && @user.hats.any? 
 select_tag "hat_id",
          options_from_collection_for_select(@user.hats, "id", "hat",
          comment.hat_id), :include_blank => true 
 end 
 if @user 
  if defined?(allow_images) && allow_images 
 end 
 
 end 
 end 
 if defined?(show_comment) && show_comment.valid? 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 end 

  end
----------------------
controller: comments
action: edit
def edit
    if !((comment = find_comment) && comment.is_editable_by_user?(@user))
      return render :text => "can't find comment", :status => 400
    end

     comment.short_id if comment.persisted? 
 form_for comment,
:html => { :id => "edit_comment_#{comment.short_id}" } do |f| 
 if comment.errors.any? 
 errors_for comment 
 end 
 hidden_field_tag "story_id", comment.story.short_id 
 if comment.parent_comment 
 hidden_field_tag "parent_comment_short_id",
      comment.parent_comment.short_id 
 end 
 text_area_tag "comment", comment.comment, :rows => 5,
      :style => "width: 100%;", :autocomplete => "off", :disabled => !@user,
      :placeholder => (@user ? "" : "You must be logged in to leave a comment.")
      
 if @user 
 end 
 button_tag "#{comment.new_record?? "Post" : "Update"}",
        :class => "comment-post", :type => "button",
        :disabled => !@user 
 button_tag "Preview", :class => "comment-preview",
        :type => "button", :disabled => !@user 
 if comment.persisted? || comment.parent_comment_id 
 button_tag "Cancel", :class => "comment-cancel",
          :type => "button" 
 end 
 if @user && @user.hats.any? 
 select_tag "hat_id",
          options_from_collection_for_select(@user.hats, "id", "hat",
          comment.hat_id), :include_blank => true 
 end 
 if @user 
  if defined?(allow_images) && allow_images 
 end 
 
 end 
 end 
 if defined?(show_comment) && show_comment.valid? 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 end 

  end
----------------------
controller: comments
action: redirect_from_short_id
def redirect_from_short_id
    if comment = find_comment
      return redirect_to comment.url
    else
      return render :text => "can't find comment", :status => 400
    end
  end
----------------------
controller: comments
action: show_short_id
def show_short_id
    if !(comment = find_comment)
      return render :text => "can't find comment", :status => 400
    end

    render :json => comment.as_json
  end
----------------------
controller: comments
action: show
def show
    if !((comment = find_comment) && comment.is_editable_by_user?(@user))
      return render :text => "can't find comment", :status => 400
    end

     comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 

  end
----------------------
controller: comments
action: create
def create
    if !(story = Story.where(:short_id => params[:story_id]).first) ||
    story.is_gone?
      return render :text => "can't find story", :status => 400
    end

    comment = story.comments.build
    comment.comment = params[:comment].to_s
    comment.user = @user

    if params[:hat_id] && @user.hats.where(:id => params[:hat_id])
      comment.hat_id = params[:hat_id]
    end

    if params[:parent_comment_short_id].present?
      if pc = Comment.where(:story_id => story.id, :short_id =>
      params[:parent_comment_short_id]).first
        comment.parent_comment = pc
      else
        return render :json => { :error => "invalid parent comment",
          :status => 400 }
      end
    end

    # prevent double-clicks of the post button
    if params[:preview].blank? &&
    (pc = Comment.where(:story_id => story.id, :user_id => @user.id,
      :parent_comment_id => comment.parent_comment_id).first)
      if (Time.now - pc.created_at) < 5.minutes
        comment.errors.add(:comment, "^You have already posted a comment " <<
          "here recently.")

        return  comment.short_id if comment.persisted? 
 form_for comment,
:html => { :id => "edit_comment_#{comment.short_id}" } do |f| 
 if comment.errors.any? 
 errors_for comment 
 end 
 hidden_field_tag "story_id", comment.story.short_id 
 if comment.parent_comment 
 hidden_field_tag "parent_comment_short_id",
      comment.parent_comment.short_id 
 end 
 text_area_tag "comment", comment.comment, :rows => 5,
      :style => "width: 100%;", :autocomplete => "off", :disabled => !@user,
      :placeholder => (@user ? "" : "You must be logged in to leave a comment.")
      
 if @user 
 end 
 button_tag "#{comment.new_record?? "Post" : "Update"}",
        :class => "comment-post", :type => "button",
        :disabled => !@user 
 button_tag "Preview", :class => "comment-preview",
        :type => "button", :disabled => !@user 
 if comment.persisted? || comment.parent_comment_id 
 button_tag "Cancel", :class => "comment-cancel",
          :type => "button" 
 end 
 if @user && @user.hats.any? 
 select_tag "hat_id",
          options_from_collection_for_select(@user.hats, "id", "hat",
          comment.hat_id), :include_blank => true 
 end 
 if @user 
  if defined?(allow_images) && allow_images 
 end 
 
 end 
 end 
 if defined?(show_comment) && show_comment.valid? 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 end 

      end
    end

    if comment.valid? && params[:preview].blank? && comment.save
      comment.current_vote = { :vote => 1 }

        comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 

    else
      comment.upvotes = 1
      comment.current_vote = { :vote => 1 }

      preview comment
    end
  end
----------------------
controller: search
action: index
def index
    @title = "Search"
    @cur_url = "/search"

    @search = Search.new

    if params[:q].to_s.present?
      @search.q = params[:q].to_s

      if params[:what].present?
        @search.what = params[:what]
      end
      if params[:order].present?
        @search.order = params[:order]
      end
      if params[:page].present?
        @search.page = params[:page].to_i
      end

      if @search.valid?
        @search.search_for_user!(@user)
      end
    end

     form_tag "/search", :method => :get do 
 text_field_tag "q", @search.q, { :size => 40 }.
        merge(@search.q.present? ? {} : { :autofocus => "autofocus" }) 
 radio_button_tag "what", "all", @search.what == "all" 
 radio_button_tag "what", "stories", @search.what == "stories" 
 radio_button_tag "what", "comments", @search.what == "comments" 
 radio_button_tag "order", "relevance", @search.order == "relevance" 
 radio_button_tag "order", "newest", @search.order == "newest" 
 radio_button_tag "order", "points", @search.order == "points" 
 end 
 if @search.total_results > -1 
 @search.total_results 
 @search.total_results == 1 ? "" :
        "s" 
 @search.q 
 @search.results.each do |res| 
 if res.class == Story 
  story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 elsif res.class == Comment 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 end 
 end 
 if @search.total_results > @search.per_page 
 page_numbers_for_pagination(@search.page_count, @search.page).each do |p| 
 if p.is_a?(Integer) 
 raw(@search.to_url_params) 
 p
            
 @search.page == p ? "cur" : "" 
 p
            
 else 
 end 
 end 
 end 
 end 

  end
----------------------
controller: signup
action: user_params
def user_params
    params.require(:user).permit(
      :username, :email, :password, :password_confirmation, :about,
    )
  end
----------------------
controller: signup
action: signup
def signup
    if !(@invitation = Invitation.where(:code => params[:invitation_code].to_s).first)
      flash[:error] = "Invalid or expired invitation."
      return redirect_to "/signup"
    end

    @title = "Signup"

    @new_user = User.new(user_params)
    @new_user.invited_by_user_id = @invitation.user_id

    if @new_user.save
      @invitation.destroy
      session[:u] = @new_user.session_token
      flash[:success] = "Welcome to #{Rails.application.name}, " <<
        "#{@new_user.username}!"

      Countinual.count!("#{Rails.application.shortname}.users.created", "+1")

      return redirect_to "/signup/invite"
    else
       form_for @new_user, { :url => signup_path,
  :autocomplete => "off" } do |f| 
 hidden_field_tag "invitation_code", @invitation.code 
 error_messages_for(@new_user) 
 f.label :invitation, "Invited By:", :class => "required" 
 @invitation.user.username 

        @invitation.user.username 
 f.label :username, "Username:", :class => "required" 
 f.text_field :username, :size => 30 
 User.username_regex 
 f.label :email, "E-mail Address:", :class => "required" 
 f.email_field :email, :size => 30 
 f.label :password, "Password:", :class => "required" 
 f.password_field :password, :size => 30, :autocomplete => "off" 
 f.label :password_confirmation, "Password (again):",
      :class => "required" 
 f.password_field :password_confirmation, :size => 30,
      :autocomplete => "off" 
 f.label :about, "About:", :class => "required" 
 f.text_area :about, :size => "100x5", :style => "width: 600px;" 
  if defined?(allow_images) && allow_images 
 end 
 
 submit_tag "Signup" 
 end 

    end
  end
----------------------
controller: signup
action: invited
def invited
    if @user
      flash[:error] = "You are already signed up."
      return redirect_to "/"
    end

    if !(@invitation = Invitation.where(:code => params[:invitation_code].to_s).first)
      flash[:error] = "Invalid or expired invitation"
      return redirect_to "/signup"
    end

    @title = "Signup"

    @new_user = User.new
    @new_user.email = @invitation.email

     form_for @new_user, { :url => signup_path,
  :autocomplete => "off" } do |f| 
 hidden_field_tag "invitation_code", @invitation.code 
 error_messages_for(@new_user) 
 f.label :invitation, "Invited By:", :class => "required" 
 @invitation.user.username 

        @invitation.user.username 
 f.label :username, "Username:", :class => "required" 
 f.text_field :username, :size => 30 
 User.username_regex 
 f.label :email, "E-mail Address:", :class => "required" 
 f.email_field :email, :size => 30 
 f.label :password, "Password:", :class => "required" 
 f.password_field :password, :size => 30, :autocomplete => "off" 
 f.label :password_confirmation, "Password (again):",
      :class => "required" 
 f.password_field :password_confirmation, :size => 30,
      :autocomplete => "off" 
 f.label :about, "About:", :class => "required" 
 f.text_area :about, :size => "100x5", :style => "width: 600px;" 
  if defined?(allow_images) && allow_images 
 end 
 
 submit_tag "Signup" 
 end 

  end
----------------------
controller: signup
action: invite
def invite
    @title = "Pass Along an Invitation"
  end
----------------------
controller: signup
action: index
def index
    if @user
      flash[:error] = "You are already signed up."
      return redirect_to "/"
    end

    @title = "Signup"
  end
----------------------
controller: stories
action: load_user_votes
def load_user_votes
    if @user
      if v = Vote.where(:user_id => @user.id, :story_id => @story.id,
      :comment_id => nil).first
        @story.vote = { :vote => v.vote, :reason => v.reason }
      end

      @story.is_hidden_by_cur_user = @story.is_hidden_by_user?(@user)

      @votes = Vote.comment_votes_by_user_for_story_hash(@user.id, @story.id)
      @comments.each do |c|
        if @votes[c.id]
          c.current_vote = @votes[c.id]
        end
      end
    end
  end
----------------------
controller: stories
action: find_user_story
def find_user_story
    if @user.is_moderator?
      @story = Story.where(:short_id => params[:story_id] || params[:id]).first
    else
      @story = Story.where(:user_id => @user.id, :short_id =>
        (params[:story_id] || params[:id])).first
    end

    if !@story
      flash[:error] = "Could not find story or you are not authorized " <<
        "to manage it."
      redirect_to "/"
      return false
    end
  end
----------------------
controller: stories
action: find_story!
def find_story!
    @story = find_story
    if !@story
      raise ActiveRecord::RecordNotFound
    end
  end
----------------------
controller: stories
action: find_story
def find_story
    story = Story.where(:short_id => params[:story_id]).first
    if @user && story
      story.vote = Vote.where(:user_id => @user.id,
        :story_id => story.id, :comment_id => nil).first.try(:vote)
    end

    story
  end
----------------------
controller: stories
action: story_params
def story_params
    p = params.require(:story).permit(
      :title, :url, :description, :moderation_reason, :seen_previous,
      :merge_story_short_id, :is_unavailable, :user_is_author, :tags_a => [],
    )

    if @user.is_moderator?
      p
    else
      p.except(:moderation_reason, :merge_story_short_id, :is_unavailable)
    end
  end
----------------------
controller: stories
action: unhide
def unhide
    if !(story = find_story)
      return render :text => "can't find story", :status => 400
    end

    HiddenStory.where(:user_id => @user.id, :story_id => story.id).delete_all

    render :text => "ok"
  end
----------------------
controller: stories
action: hide
def hide
    if !(story = find_story)
      return render :text => "can't find story", :status => 400
    end

    HiddenStory.hide_story_for_user(story.id, @user.id)

    render :text => "ok"
  end
----------------------
controller: stories
action: downvote
def downvote
    if !(story = find_story)
      return render :text => "can't find story", :status => 400
    end

    if !Vote::STORY_REASONS[params[:reason]]
      return render :text => "invalid reason", :status => 400
    end

    if !@user.can_downvote?(story)
      return render :text => "not permitted to downvote", :status => 400
    end

    Vote.vote_thusly_on_story_or_comment_for_user_because(-1, story.id,
      nil, @user.id, params[:reason])

    render :text => "ok"
  end
----------------------
controller: stories
action: upvote
def upvote
    if !(story = find_story)
      return render :text => "can't find story", :status => 400
    end

    Vote.vote_thusly_on_story_or_comment_for_user_because(1, story.id,
      nil, @user.id, nil)

    render :text => "ok"
  end
----------------------
controller: stories
action: unvote
def unvote
    if !(story = find_story)
      return render :text => "can't find story", :status => 400
    end

    Vote.vote_thusly_on_story_or_comment_for_user_because(0, story.id,
      nil, @user.id, nil)

    render :text => "ok"
  end
----------------------
controller: stories
action: update
def update
    if !@story.is_editable_by_user?(@user)
      flash[:error] = "You cannot edit that story."
      return redirect_to "/"
    end

    @story.is_expired = false
    @story.editor = @user

    if @story.url_is_editable_by_user?(@user)
      @story.attributes = story_params
    else
      @story.attributes = story_params.except(:url)
    end

    if @story.save
      return redirect_to @story.comments_path
    else
      return  form_for @story, :url => story_path(@story.short_id),
  :method => :put, :html => { :id => "edit_story" } do |f| 
  if f.object.errors.count == 1 && f.object.already_posted_story 

    time_ago_in_words_label(f.object.already_posted_story.created_at) 
 f.object.already_posted_story.comments_path 
 elsif f.object.errors.any? 
 error_messages_for f.object 
 elsif !f.object.errors.any? && f.object.already_posted_story 

    time_ago_in_words_label(f.object.already_posted_story.created_at) 
 f.object.already_posted_story.comments_path 
 f.hidden_field :seen_previous 
 end 
 unless defined?(suggesting) 
 if f.object.url_is_editable_by_user?(@user) 
 f.label :url, "URL:", :class => "required" 
 f.text_field :url, :autocomplete => "off" 
 button_tag "Fetch Title", :id => "story_fetch_title",
        :type => "button" 
 elsif !f.object.new_record? && !f.object.url.blank? 
 f.label :url, "URL:", :class => "required" 
 f.object.url 
 f.object.url 
 end 
 end 
 f.label :title, "Title:", :class => "required" 
 f.text_field :title, :maxlength => 100, :autocomplete => "off"  
 if f.object.id && !defined?(suggesting) 
 title_votes = {} 
 f.object.suggested_titles.each do |st| 
 title_votes[st.title] ||= 0 
 title_votes[st.title] += 1 
 end 
 title_votes.delete(f.object.title) 
 if title_votes.any? 
 title_votes.each do |ti,c| 
 h(ti) 
 c == 1 ? "" : " (#{c} votes)" 
 end 
 end 
 end 
 f.label :tags_a, "Tags:", :class => "required",
    :style => "line-height: 2.3em;" 
 f.select "tags_a", options_for_select(
    Tag.all_with_filtered_counts_for(@user).map{|t|
      html = "<strong>#{h(t.tag)}</strong> - #{h(t.description.to_s)}"

      if t.hotness_mod != 0
        html << " (hotness mod #{t.hotness_mod > 0 ? "+" : ""}#{t.hotness_mod})"
      end
      if t.filtered_count > 0
        html << " <em>#{t.filtered_count} user" <<
          (t.filtered_count == 1 ? "" : "s") << " filtering</em>"
      end

      [ "#{t.tag} - #{t.description}", t.tag, { "data-html" => raw(html) } ]},
    f.object.tags_a), {}, { :multiple => true } 
 if f.object.id && !defined?(suggesting) 
 tag_votes = {} 
 f.object.suggested_taggings.group_by(&:user_id).each do |u,stg| 
 tl = stg.map{|st| st.tag.tag }.sort.join(", ") 
 tag_votes[tl] ||= 0 
 tag_votes[tl] += 1 
 end 
 tag_votes.delete(f.object.tags_a.sort.join(", ")) 
 if tag_votes.any? 
 tag_votes.each do |ts,c| 
 ts 
 c == 1 ? "" : " (#{c} votes)" 
 end 
 end 
 end 
 unless defined?(suggesting) 
 f.label :description, "Text:", :class => "required" 
 f.text_area :description, :rows => 15,
        :placeholder => "Optional when submitting a URL; please see guidelines",
        :autocomplete => "off" 
 show_guidelines?? "" :
      "display: none;" 
 Rails.application.root_url
        

        
 Rails.application.name 
 Rails.application.name 
 end 
 unless defined?(suggesting) 
 f.label :user_is_author, "Author:", :class => "required" 
 f.check_box :user_is_author 
 f.label :user_is_author,
        (f.object.id && f.object.user_id != @user.id ? "Submitter is" : "I am") +
        " the author of the story at this URL (or this text)",
        :class => "normal" 
 end 
 
 end 

    end
  end
----------------------
controller: stories
action: undelete
def undelete
    if !(@story.is_editable_by_user?(@user) &&
    @story.is_undeletable_by_user?(@user))
      flash[:error] = "You cannot edit that story."
      return redirect_to "/"
    end

    @story.is_expired = false
    @story.editor = @user
    @story.save(:validate => false)

    redirect_to @story.comments_path
  end
----------------------
controller: stories
action: submit_suggestions
def submit_suggestions
    ostory = @story.dup

    @story.title = params[:story][:title]
    if @story.valid?
      dsug = false
      if @story.title != ostory.title
        @story.save_suggested_title_for_user!(@story.title, @user)
        dsug = true
      end

      sugtags = params[:story][:tags_a].reject{|t| t.to_s.strip == "" }.sort
      if @story.tags_a.sort != sugtags
        @story.save_suggested_tags_a_for_user!(sugtags, @user)
        dsug = true
      end

      if dsug
        ostory = @story.reload
        flash[:success] = "Your suggested changes have been noted."
      end
      redirect_to ostory.comments_path
    else
       form_for @story, :url => story_suggest_path(@story.short_id),
  :method => :post, :html => { :id => "edit_story" } do |f| 
  if f.object.errors.count == 1 && f.object.already_posted_story 

    time_ago_in_words_label(f.object.already_posted_story.created_at) 
 f.object.already_posted_story.comments_path 
 elsif f.object.errors.any? 
 error_messages_for f.object 
 elsif !f.object.errors.any? && f.object.already_posted_story 

    time_ago_in_words_label(f.object.already_posted_story.created_at) 
 f.object.already_posted_story.comments_path 
 f.hidden_field :seen_previous 
 end 
 unless defined?(suggesting) 
 if f.object.url_is_editable_by_user?(@user) 
 f.label :url, "URL:", :class => "required" 
 f.text_field :url, :autocomplete => "off" 
 button_tag "Fetch Title", :id => "story_fetch_title",
        :type => "button" 
 elsif !f.object.new_record? && !f.object.url.blank? 
 f.label :url, "URL:", :class => "required" 
 f.object.url 
 f.object.url 
 end 
 end 
 f.label :title, "Title:", :class => "required" 
 f.text_field :title, :maxlength => 100, :autocomplete => "off"  
 if f.object.id && !defined?(suggesting) 
 title_votes = {} 
 f.object.suggested_titles.each do |st| 
 title_votes[st.title] ||= 0 
 title_votes[st.title] += 1 
 end 
 title_votes.delete(f.object.title) 
 if title_votes.any? 
 title_votes.each do |ti,c| 
 h(ti) 
 c == 1 ? "" : " (#{c} votes)" 
 end 
 end 
 end 
 f.label :tags_a, "Tags:", :class => "required",
    :style => "line-height: 2.3em;" 
 f.select "tags_a", options_for_select(
    Tag.all_with_filtered_counts_for(@user).map{|t|
      html = "<strong>#{h(t.tag)}</strong> - #{h(t.description.to_s)}"

      if t.hotness_mod != 0
        html << " (hotness mod #{t.hotness_mod > 0 ? "+" : ""}#{t.hotness_mod})"
      end
      if t.filtered_count > 0
        html << " <em>#{t.filtered_count} user" <<
          (t.filtered_count == 1 ? "" : "s") << " filtering</em>"
      end

      [ "#{t.tag} - #{t.description}", t.tag, { "data-html" => raw(html) } ]},
    f.object.tags_a), {}, { :multiple => true } 
 if f.object.id && !defined?(suggesting) 
 tag_votes = {} 
 f.object.suggested_taggings.group_by(&:user_id).each do |u,stg| 
 tl = stg.map{|st| st.tag.tag }.sort.join(", ") 
 tag_votes[tl] ||= 0 
 tag_votes[tl] += 1 
 end 
 tag_votes.delete(f.object.tags_a.sort.join(", ")) 
 if tag_votes.any? 
 tag_votes.each do |ts,c| 
 ts 
 c == 1 ? "" : " (#{c} votes)" 
 end 
 end 
 end 
 unless defined?(suggesting) 
 f.label :description, "Text:", :class => "required" 
 f.text_area :description, :rows => 15,
        :placeholder => "Optional when submitting a URL; please see guidelines",
        :autocomplete => "off" 
 show_guidelines?? "" :
      "display: none;" 
 Rails.application.root_url
        

        
 Rails.application.name 
 Rails.application.name 
 end 
 unless defined?(suggesting) 
 f.label :user_is_author, "Author:", :class => "required" 
 f.check_box :user_is_author 
 f.label :user_is_author,
        (f.object.id && f.object.user_id != @user.id ? "Submitter is" : "I am") +
        " the author of the story at this URL (or this text)",
        :class => "normal" 
 end 
 
 end 

    end
  end
----------------------
controller: stories
action: suggest
def suggest
    if (st = @story.suggested_taggings.where(:user_id => @user.id)).any?
      @story.tags_a = st.map{|st| st.tag.tag }
    end
    if tt = @story.suggested_titles.where(:user_id => @user.id).first
      @story.title = tt.title
    end
  end
----------------------
controller: stories
action: show
def show
    @story = Story.where(:short_id => params[:id]).first!

    if @story.merged_into_story
      flash[:success] = "\"#{@story.title}\" has been merged into this story."
      return redirect_to @story.merged_into_story.comments_path
    end

    if @story.can_be_seen_by_user?(@user)
      @title = @story.title
    else
      @title = "[Story removed]"
    end

    @short_url = @story.short_id_url

    @comments = @story.merged_comments.includes(:user, :story,
      :hat).arrange_for_user(@user)

    if params[:comment_short_id]
      @comments.each do |c,x|
        if c.short_id == params[:comment_short_id]
          c.highlighted = true
          break
        end
      end
    end

    respond_to do |format|
      format.html {
        @comment = @story.comments.build

        @meta_tags = {
          "twitter:card" => "summary",
          "twitter:site" => "@lobsters",
          "twitter:title" => @story.title,
          "twitter:description" => "#{@story.comments_count} comment" <<
            "#{@story.comments_count == 1 ? "" : "s"}",
        }

        load_user_votes

          story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @story.markeddown_description.present? 
 raw @story.markeddown_description 
 end 
 if @story.is_unavailable && @story.story_cache.present? 

    time_ago_in_words_label(@story.unavailable_at) 
 simple_format(@story.story_cache) 
 end 
 if !@story.previewing 
 if !@story.is_gone? && !@story.previewing 
  comment.short_id if comment.persisted? 
 form_for comment,
:html => { :id => "edit_comment_#{comment.short_id}" } do |f| 
 if comment.errors.any? 
 errors_for comment 
 end 
 hidden_field_tag "story_id", comment.story.short_id 
 if comment.parent_comment 
 hidden_field_tag "parent_comment_short_id",
      comment.parent_comment.short_id 
 end 
 text_area_tag "comment", comment.comment, :rows => 5,
      :style => "width: 100%;", :autocomplete => "off", :disabled => !@user,
      :placeholder => (@user ? "" : "You must be logged in to leave a comment.")
      
 if @user 
 end 
 button_tag "#{comment.new_record?? "Post" : "Update"}",
        :class => "comment-post", :type => "button",
        :disabled => !@user 
 button_tag "Preview", :class => "comment-preview",
        :type => "button", :disabled => !@user 
 if comment.persisted? || comment.parent_comment_id 
 button_tag "Cancel", :class => "comment-cancel",
          :type => "button" 
 end 
 if @user && @user.hats.any? 
 select_tag "hat_id",
          options_from_collection_for_select(@user.hats, "id", "hat",
          comment.hat_id), :include_blank => true 
 end 
 if @user 
  if defined?(allow_images) && allow_images 
 end 
 
 end 
 end 
 if defined?(show_comment) && show_comment.valid? 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 end 
 
 end 
 comments_by_parent = @comments.group_by(&:parent_comment_id) 
 subtree = comments_by_parent[nil] 
 ancestors = [] 
 while subtree 
 if (comment = subtree.shift) 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 elsif (subtree = ancestors.pop) 
 end 
 end 
 end 

      }
      format.json {
        render :json => @story.as_json(:with_comments => @comments)
      }
    end
  end
----------------------
controller: stories
action: preview
def preview
    @story = Story.new(story_params)
    @story.user_id = @user.id
    @story.previewing = true

    @story.vote = Vote.new(:vote => 1)
    @story.upvotes = 1

    @story.valid?

    @story.seen_previous = true

    return  form_for @story do |f| 
  if f.object.errors.count == 1 && f.object.already_posted_story 

    time_ago_in_words_label(f.object.already_posted_story.created_at) 
 f.object.already_posted_story.comments_path 
 elsif f.object.errors.any? 
 error_messages_for f.object 
 elsif !f.object.errors.any? && f.object.already_posted_story 

    time_ago_in_words_label(f.object.already_posted_story.created_at) 
 f.object.already_posted_story.comments_path 
 f.hidden_field :seen_previous 
 end 
 unless defined?(suggesting) 
 if f.object.url_is_editable_by_user?(@user) 
 f.label :url, "URL:", :class => "required" 
 f.text_field :url, :autocomplete => "off" 
 button_tag "Fetch Title", :id => "story_fetch_title",
        :type => "button" 
 elsif !f.object.new_record? && !f.object.url.blank? 
 f.label :url, "URL:", :class => "required" 
 f.object.url 
 f.object.url 
 end 
 end 
 f.label :title, "Title:", :class => "required" 
 f.text_field :title, :maxlength => 100, :autocomplete => "off"  
 if f.object.id && !defined?(suggesting) 
 title_votes = {} 
 f.object.suggested_titles.each do |st| 
 title_votes[st.title] ||= 0 
 title_votes[st.title] += 1 
 end 
 title_votes.delete(f.object.title) 
 if title_votes.any? 
 title_votes.each do |ti,c| 
 h(ti) 
 c == 1 ? "" : " (#{c} votes)" 
 end 
 end 
 end 
 f.label :tags_a, "Tags:", :class => "required",
    :style => "line-height: 2.3em;" 
 f.select "tags_a", options_for_select(
    Tag.all_with_filtered_counts_for(@user).map{|t|
      html = "<strong>#{h(t.tag)}</strong> - #{h(t.description.to_s)}"

      if t.hotness_mod != 0
        html << " (hotness mod #{t.hotness_mod > 0 ? "+" : ""}#{t.hotness_mod})"
      end
      if t.filtered_count > 0
        html << " <em>#{t.filtered_count} user" <<
          (t.filtered_count == 1 ? "" : "s") << " filtering</em>"
      end

      [ "#{t.tag} - #{t.description}", t.tag, { "data-html" => raw(html) } ]},
    f.object.tags_a), {}, { :multiple => true } 
 if f.object.id && !defined?(suggesting) 
 tag_votes = {} 
 f.object.suggested_taggings.group_by(&:user_id).each do |u,stg| 
 tl = stg.map{|st| st.tag.tag }.sort.join(", ") 
 tag_votes[tl] ||= 0 
 tag_votes[tl] += 1 
 end 
 tag_votes.delete(f.object.tags_a.sort.join(", ")) 
 if tag_votes.any? 
 tag_votes.each do |ts,c| 
 ts 
 c == 1 ? "" : " (#{c} votes)" 
 end 
 end 
 end 
 unless defined?(suggesting) 
 f.label :description, "Text:", :class => "required" 
 f.text_area :description, :rows => 15,
        :placeholder => "Optional when submitting a URL; please see guidelines",
        :autocomplete => "off" 
 show_guidelines?? "" :
      "display: none;" 
 Rails.application.root_url
        

        
 Rails.application.name 
 Rails.application.name 
 end 
 unless defined?(suggesting) 
 f.label :user_is_author, "Author:", :class => "required" 
 f.check_box :user_is_author 
 f.label :user_is_author,
        (f.object.id && f.object.user_id != @user.id ? "Submitter is" : "I am") +
        " the author of the story at this URL (or this text)",
        :class => "normal" 
 end 
 
 end 
 if @story.previewing && @story.valid? 
   story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @story.markeddown_description.present? 
 raw @story.markeddown_description 
 end 
 if @story.is_unavailable && @story.story_cache.present? 

    time_ago_in_words_label(@story.unavailable_at) 
 simple_format(@story.story_cache) 
 end 
 if !@story.previewing 
 if !@story.is_gone? && !@story.previewing 
  comment.short_id if comment.persisted? 
 form_for comment,
:html => { :id => "edit_comment_#{comment.short_id}" } do |f| 
 if comment.errors.any? 
 errors_for comment 
 end 
 hidden_field_tag "story_id", comment.story.short_id 
 if comment.parent_comment 
 hidden_field_tag "parent_comment_short_id",
      comment.parent_comment.short_id 
 end 
 text_area_tag "comment", comment.comment, :rows => 5,
      :style => "width: 100%;", :autocomplete => "off", :disabled => !@user,
      :placeholder => (@user ? "" : "You must be logged in to leave a comment.")
      
 if @user 
 end 
 button_tag "#{comment.new_record?? "Post" : "Update"}",
        :class => "comment-post", :type => "button",
        :disabled => !@user 
 button_tag "Preview", :class => "comment-preview",
        :type => "button", :disabled => !@user 
 if comment.persisted? || comment.parent_comment_id 
 button_tag "Cancel", :class => "comment-cancel",
          :type => "button" 
 end 
 if @user && @user.hats.any? 
 select_tag "hat_id",
          options_from_collection_for_select(@user.hats, "id", "hat",
          comment.hat_id), :include_blank => true 
 end 
 if @user 
  if defined?(allow_images) && allow_images 
 end 
 
 end 
 end 
 if defined?(show_comment) && show_comment.valid? 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 end 
 
 end 
 comments_by_parent = @comments.group_by(&:parent_comment_id) 
 subtree = comments_by_parent[nil] 
 ancestors = [] 
 while subtree 
 if (comment = subtree.shift) 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 elsif (subtree = ancestors.pop) 
 end 
 end 
 end 
 
 end 
 if !@story.previewing 
 end 

  end
----------------------
controller: stories
action: new
def new
    @title = "Submit Story"
    @cur_url = "/stories/new"

    @story = Story.new
    @story.fetching_ip = request.remote_ip

    if params[:url].present?
      @story.url = params[:url]

      sattrs = @story.fetched_attributes

      if sattrs[:url].present? && @story.url != sattrs[:url]
        flash.now[:notice] = "Note: URL has been changed to fetched " <<
          "canonicalized version"
        @story.url = sattrs[:url]
      end

      if s = Story.find_similar_by_url(@story.url)
        if s.is_recent?
          # user won't be able to submit this story as new, so just redirect
          # them to the previous story
          flash[:success] = "This URL has already been submitted recently."
          return redirect_to s.comments_path
        else
          # user will see a warning like with preview screen
          @story.already_posted_story = s
        end
      end

      # ignore what the user brought unless we need it as a fallback
      @story.title = sattrs[:title]
      if !@story.title.present? && params[:title].present?
        @story.title = params[:title]
      end
    end
  end
----------------------
controller: stories
action: fetch_url_attributes
def fetch_url_attributes
    s = Story.new
    s.fetching_ip = request.remote_ip
    s.url = params[:fetch_url]

    return render :json => s.fetched_attributes
  end
----------------------
controller: stories
action: edit
def edit
    if !@story.is_editable_by_user?(@user)
      flash[:error] = "You cannot edit that story."
      return redirect_to "/"
    end

    @title = "Edit Story"

    if @story.merged_into_story
      @story.merge_story_short_id = @story.merged_into_story.short_id
    end
  end
----------------------
controller: stories
action: destroy
def destroy
    if !@story.is_editable_by_user?(@user)
      flash[:error] = "You cannot edit that story."
      return redirect_to "/"
    end

    @story.is_expired = true
    @story.editor = @user

    if params[:reason].present? && @story.user_id != @user.id
      @story.moderation_reason = params[:reason]
    end

    @story.save(:validate => false)

    redirect_to @story.comments_path
  end
----------------------
controller: stories
action: create
def create
    @title = "Submit Story"
    @cur_url = "/stories/new"

    @story = Story.new(story_params)
    @story.user_id = @user.id

    if @story.valid? && !(@story.already_posted_story && !@story.seen_previous)
      if @story.save
        Countinual.count!("#{Rails.application.shortname}.stories.submitted",
          "+1")

        return redirect_to @story.comments_path
      end
    end

    return  form_for @story do |f| 
  if f.object.errors.count == 1 && f.object.already_posted_story 

    time_ago_in_words_label(f.object.already_posted_story.created_at) 
 f.object.already_posted_story.comments_path 
 elsif f.object.errors.any? 
 error_messages_for f.object 
 elsif !f.object.errors.any? && f.object.already_posted_story 

    time_ago_in_words_label(f.object.already_posted_story.created_at) 
 f.object.already_posted_story.comments_path 
 f.hidden_field :seen_previous 
 end 
 unless defined?(suggesting) 
 if f.object.url_is_editable_by_user?(@user) 
 f.label :url, "URL:", :class => "required" 
 f.text_field :url, :autocomplete => "off" 
 button_tag "Fetch Title", :id => "story_fetch_title",
        :type => "button" 
 elsif !f.object.new_record? && !f.object.url.blank? 
 f.label :url, "URL:", :class => "required" 
 f.object.url 
 f.object.url 
 end 
 end 
 f.label :title, "Title:", :class => "required" 
 f.text_field :title, :maxlength => 100, :autocomplete => "off"  
 if f.object.id && !defined?(suggesting) 
 title_votes = {} 
 f.object.suggested_titles.each do |st| 
 title_votes[st.title] ||= 0 
 title_votes[st.title] += 1 
 end 
 title_votes.delete(f.object.title) 
 if title_votes.any? 
 title_votes.each do |ti,c| 
 h(ti) 
 c == 1 ? "" : " (#{c} votes)" 
 end 
 end 
 end 
 f.label :tags_a, "Tags:", :class => "required",
    :style => "line-height: 2.3em;" 
 f.select "tags_a", options_for_select(
    Tag.all_with_filtered_counts_for(@user).map{|t|
      html = "<strong>#{h(t.tag)}</strong> - #{h(t.description.to_s)}"

      if t.hotness_mod != 0
        html << " (hotness mod #{t.hotness_mod > 0 ? "+" : ""}#{t.hotness_mod})"
      end
      if t.filtered_count > 0
        html << " <em>#{t.filtered_count} user" <<
          (t.filtered_count == 1 ? "" : "s") << " filtering</em>"
      end

      [ "#{t.tag} - #{t.description}", t.tag, { "data-html" => raw(html) } ]},
    f.object.tags_a), {}, { :multiple => true } 
 if f.object.id && !defined?(suggesting) 
 tag_votes = {} 
 f.object.suggested_taggings.group_by(&:user_id).each do |u,stg| 
 tl = stg.map{|st| st.tag.tag }.sort.join(", ") 
 tag_votes[tl] ||= 0 
 tag_votes[tl] += 1 
 end 
 tag_votes.delete(f.object.tags_a.sort.join(", ")) 
 if tag_votes.any? 
 tag_votes.each do |ts,c| 
 ts 
 c == 1 ? "" : " (#{c} votes)" 
 end 
 end 
 end 
 unless defined?(suggesting) 
 f.label :description, "Text:", :class => "required" 
 f.text_area :description, :rows => 15,
        :placeholder => "Optional when submitting a URL; please see guidelines",
        :autocomplete => "off" 
 show_guidelines?? "" :
      "display: none;" 
 Rails.application.root_url
        

        
 Rails.application.name 
 Rails.application.name 
 end 
 unless defined?(suggesting) 
 f.label :user_is_author, "Author:", :class => "required" 
 f.check_box :user_is_author 
 f.label :user_is_author,
        (f.object.id && f.object.user_id != @user.id ? "Submitter is" : "I am") +
        " the author of the story at this URL (or this text)",
        :class => "normal" 
 end 
 
 end 
 if @story.previewing && @story.valid? 
   story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @story.markeddown_description.present? 
 raw @story.markeddown_description 
 end 
 if @story.is_unavailable && @story.story_cache.present? 

    time_ago_in_words_label(@story.unavailable_at) 
 simple_format(@story.story_cache) 
 end 
 if !@story.previewing 
 if !@story.is_gone? && !@story.previewing 
  comment.short_id if comment.persisted? 
 form_for comment,
:html => { :id => "edit_comment_#{comment.short_id}" } do |f| 
 if comment.errors.any? 
 errors_for comment 
 end 
 hidden_field_tag "story_id", comment.story.short_id 
 if comment.parent_comment 
 hidden_field_tag "parent_comment_short_id",
      comment.parent_comment.short_id 
 end 
 text_area_tag "comment", comment.comment, :rows => 5,
      :style => "width: 100%;", :autocomplete => "off", :disabled => !@user,
      :placeholder => (@user ? "" : "You must be logged in to leave a comment.")
      
 if @user 
 end 
 button_tag "#{comment.new_record?? "Post" : "Update"}",
        :class => "comment-post", :type => "button",
        :disabled => !@user 
 button_tag "Preview", :class => "comment-preview",
        :type => "button", :disabled => !@user 
 if comment.persisted? || comment.parent_comment_id 
 button_tag "Cancel", :class => "comment-cancel",
          :type => "button" 
 end 
 if @user && @user.hats.any? 
 select_tag "hat_id",
          options_from_collection_for_select(@user.hats, "id", "hat",
          comment.hat_id), :include_blank => true 
 end 
 if @user 
  if defined?(allow_images) && allow_images 
 end 
 
 end 
 end 
 if defined?(show_comment) && show_comment.valid? 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 end 
 
 end 
 comments_by_parent = @comments.group_by(&:parent_comment_id) 
 subtree = comments_by_parent[nil] 
 ancestors = [] 
 while subtree 
 if (comment = subtree.shift) 
  comment.short_id 
 comment.short_id 
 comment.short_id if comment.persisted? 
 comment.current_vote ? (comment.current_vote[:vote] == 1 ?
"upvoted" : "downvoted") : "" 
 comment.highlighted ? "highlighted" : "" 
 comment.score <= 0 ? "negative" : "" 
 comment.score <= -1 ? "negative_1" : "" 
 comment.score <= -3 ? "negative_3" : "" 
 comment.score <= -5 ? "negative_5" : "" 
 if !comment.is_gone? 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 comment.score 
 if @user && @user.can_downvote?(comment) 
 else 
 end 
 end 
 comment.short_id 
 comment.short_id 
 if defined?(was_merged) && was_merged 
 end 
 if @user && @user.show_avatars? 
 comment.user.username 
 comment.user.avatar_url(16) 
 end 
 comment.user.username 
 comment.html_class_for_user 

        comment.user.username 
 if comment.hat 
 comment.hat.to_html_label 
 end 
 if comment.previewing 
 else 
 if comment.has_been_edited? 
 elsif comment.is_from_email? 
 end 
 time_ago_in_words_label((comment.has_been_edited? ?
          comment.updated_at : comment.created_at), :strip_about => true) 
 end 
 if !comment.previewing 
 comment.url 
 if comment.is_editable_by_user?(@user) 
 end 
 if comment.is_gone? && comment.is_undeletable_by_user?(@user) 
 elsif !comment.is_gone? && comment.is_deletable_by_user?(@user) 
 end 
 if @user && !comment.story.is_gone? && !comment.is_gone? 
 end 
 if comment.downvotes > 0 &&
          ((comment.score <= 0 && comment.user_id == @user.try(:id)) ||
          @user.try("is_moderator?")) 
 comment.vote_summary.downcase 
 elsif comment.current_vote && comment.current_vote[:vote] == -1 
 Vote::COMMENT_REASONS[comment.current_vote[:reason]].downcase 
 end 
 end 
 if defined?(show_story) && show_story 
 comment.story.comments_path 
 comment.story.title
          
 end 
 if comment.is_gone? 
 comment.gone_text 
 else 
 raw comment.markeddown_comment 
 end 
 
 elsif (subtree = ancestors.pop) 
 end 
 end 
 end 
 
 end 
 if !@story.previewing 
 end 

  end
----------------------
controller: moderations
action: index
def index
    @title = "Moderation Log"

    @page = params[:page] ? params[:page].to_i : 0
    @pages = (Moderation.count / 50).ceil

    if @page < 1
      @page = 1
    elsif @page > @pages
      @page = @pages
    end

    @moderations = Moderation.order("id desc").limit(50).offset((@page - 1) *
      50)
  end
----------------------
controller: messages
action: find_message
def find_message
    if @message = Message.where(:short_id => params[:message_id] ||
    params[:id]).first
      if (@message.author_user_id == @user.id ||
      @message.recipient_user_id == @user.id)
        return true
      end
    end

    flash[:error] = "Could not find message."
    redirect_to "/messages"
    return false
  end
----------------------
controller: messages
action: message_params
def message_params
    params.require(:message).permit(
      :recipient_username, :subject, :body,
    )
  end
----------------------
controller: messages
action: keep_as_new
def keep_as_new
    @message.has_been_read = false
    @message.save

    return redirect_to "/messages"
  end
----------------------
controller: messages
action: batch_delete
def batch_delete
    deleted = 0

    params.each do |k,v|
      if v.to_s == "1" && m = k.match(/^delete_(.+)$/)
        if (message = Message.where(:short_id => m[1]).first)
          ok = false
          if message.author_user_id == @user.id
            message.deleted_by_author = true
            ok = true
          end
          if message.recipient_user_id == @user.id
            message.deleted_by_recipient = true
            ok = true
          end

          if ok
            message.save!
            deleted += 1
          end
        end
      end
    end

    flash[:success] = "Deleted #{deleted} message#{deleted == 1 ? "" : "s"}."

    @user.update_unread_message_count!

    return redirect_to "/messages"
  end
----------------------
controller: messages
action: destroy
def destroy
    if @message.author_user_id == @user.id
      @message.deleted_by_author = true
    end

    if @message.recipient_user_id == @user.id
      @message.deleted_by_recipient = true
    end

    @message.save!

    flash[:success] = "Deleted message."

    if @message.author_user_id == @user.id
      return redirect_to "/messages/sent"
    else
      return redirect_to "/messages"
    end
  end
----------------------
controller: messages
action: show
def show
    @cur_url = "/messages"
    @title = @message.subject

    if @message.author
      @new_message = Message.new
      @new_message.recipient_username = (@message.author_user_id == @user.id ?
        @message.recipient.username : @message.author.username)

      if @message.subject.match(/^re:/i)
        @new_message.subject = @message.subject
      else
        @new_message.subject = "Re: #{@message.subject}"
      end
    end

    if @message.recipient_user_id == @user.id
      @message.has_been_read = true
      @message.save
    end
  end
----------------------
controller: messages
action: create
def create
    @cur_url = "/messages"
    @title = "Messages"

    @new_message = Message.new(message_params)
    @new_message.author_user_id = @user.id

    @direction = :out
    @messages = @user.undeleted_received_messages

    if @new_message.save
      flash[:success] = "Your message has been sent to " <<
        @new_message.recipient.username.to_s << "."
      return redirect_to "/messages"
    else
       if @direction == :out 
 else 
 end 
 if @direction == :out 
 end 
 if @messages.any? 
 form_tag batch_delete_messages_path do 
 check_box_tag "delete_all",
          :id => "delete_all" 
 @direction == :in ? "From" : "To" 
 @direction == :in ? "Received" : "Sent" 
 @messages.includes(:author, :recipient).each do |message| 
 message.has_been_read? ? "" : "bold" 
 check_box_tag "delete_#{message.short_id}" 
 if @direction == :in 
 if message.author 
 message.author.username 

                  message.author.username 
 else 
 message.author_username 
 end 
 else 
 message.recipient.username 

                message.recipient.username 
 end 
 time_ago_in_words_label(message.created_at) 
 message.short_id 
 message.subject
            
 end 
 submit_tag "Delete Selected" 
 end 
 else 
 @direction == :in ? "" : "sent" 
 end 
 form_for @new_message, :method => :post do |f| 
 error_messages_for @new_message 
 f.label :recipient_username, "To:", :class => "required" 
 f.text_field :recipient_username, :size => 20,
        :autocomplete => "off" 
 f.label :subject, "Subject:", :class => "required" 
 f.text_field :subject, :style => "width: 500px;",
        :autocomplete => "off" 
 f.label :body, "Message:", :class => "required" 
 f.text_area :body, :style => "width: 500px;", :rows => 5,
        :autocomplete => "off" 
 submit_tag "Send Message" 
 end 

    end
  end
----------------------
controller: messages
action: sent
def sent
    @cur_url = "/messages"
    @title = "Messages Sent"

    @direction = :out
    @messages = @user.undeleted_sent_messages

    @new_message = Message.new

     if @direction == :out 
 else 
 end 
 if @direction == :out 
 end 
 if @messages.any? 
 form_tag batch_delete_messages_path do 
 check_box_tag "delete_all",
          :id => "delete_all" 
 @direction == :in ? "From" : "To" 
 @direction == :in ? "Received" : "Sent" 
 @messages.includes(:author, :recipient).each do |message| 
 message.has_been_read? ? "" : "bold" 
 check_box_tag "delete_#{message.short_id}" 
 if @direction == :in 
 if message.author 
 message.author.username 

                  message.author.username 
 else 
 message.author_username 
 end 
 else 
 message.recipient.username 

                message.recipient.username 
 end 
 time_ago_in_words_label(message.created_at) 
 message.short_id 
 message.subject
            
 end 
 submit_tag "Delete Selected" 
 end 
 else 
 @direction == :in ? "" : "sent" 
 end 
 form_for @new_message, :method => :post do |f| 
 error_messages_for @new_message 
 f.label :recipient_username, "To:", :class => "required" 
 f.text_field :recipient_username, :size => 20,
        :autocomplete => "off" 
 f.label :subject, "Subject:", :class => "required" 
 f.text_field :subject, :style => "width: 500px;",
        :autocomplete => "off" 
 f.label :body, "Message:", :class => "required" 
 f.text_area :body, :style => "width: 500px;", :rows => 5,
        :autocomplete => "off" 
 submit_tag "Send Message" 
 end 

  end
----------------------
controller: messages
action: index
def index
    @cur_url = "/messages"
    @title = "Messages"

    @new_message = Message.new

    @direction = :in
    @messages = @user.undeleted_received_messages

    if params[:to]
      @new_message.recipient_username = params[:to]
    end
  end
----------------------
controller: home
action: get_from_cache(opts={},
def get_from_cache(opts={}, &block)
    if Rails.env.development? || @user || tags_filtered_by_cookie.any?
      yield
    else
      key = opts.merge(page: page).sort.map{|k,v| "#{k}=#{v.to_param}"
        }.join(" ")
      Rails.cache.fetch("stories #{key}", :expires_in => 45, &block)
    end
  end
----------------------
controller: home
action: paginate(scope)
def paginate(scope)
    StoriesPaginator.new(scope, page, @user).get
  end
----------------------
controller: home
action: page
def page
    params[:page].to_i > 0 ? params[:page].to_i : 1
  end
----------------------
controller: home
action: stories
def stories
    StoryRepository.new(@user, exclude_tags: filtered_tag_ids)
  end
----------------------
controller: home
action: filtered_tag_ids
def filtered_tag_ids
    if @user
      @user.tag_filters.map{|tf| tf.tag_id }
    else
      tags_filtered_by_cookie.map{|t| t.id }
    end
  end
----------------------
controller: home
action: upvoted
def upvoted
    @stories, @show_more = get_from_cache(upvoted: true, user: @user) {
      paginate @user.upvoted_stories.order('votes.id DESC')
    }

    @heading = @title = "Your Upvoted Stories"
    @cur_url = "/upvoted"

    @rss_link = { :title => "RSS 2.0 - Your Upvoted Stories",
      :href => "/upvoted.rss#{(@user ? "?token=#{@user.rss_token}" : "")}" }

    respond_to do |format|
      format.html {  if @cur_url == "/recent" 
 end 
 @cur_url == "/hidden" ? "show_hidden" : "" 
  story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @page && @page > 1 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page == 2 ? "" : "page/#{@page - 1}" 
 @page - 1 
 end 
 if @show_more 
 if @page && @page > 1 
 end 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page + 1 
 @page + 1 
 end 
 }
      format.rss {
        if @user && params[:token].present?
          @title += " - Private feed for #{@user.username}"
        end

         coder = HTMLEntities.new 
 Rails.application.name 
 @title.present? ?
      ": " + h(@title) : "" 
 @title 
 Rails.application.root_url + (@newest ? "newest" : "") 
 @stories.each do |story| 
 raw coder.encode(story.title, :decimal) 
 story.url_or_comments_url 
 story.short_id_url 
 story.user.username 
 story.created_at.rfc2822 
 story.comments_url 
 raw coder.encode(story.markeddown_description, :decimal) 
 if story.url.present? 
 raw coder.encode("<p>" +
              link_to("Comments", story.comments_url) + "</p>", :decimal) 
 end 
 story.taggings.each do |tagging| 
 tagging.tag.tag 
 end 
 end 

      }
      format.json { render :json => @stories }
    end
  end
----------------------
controller: home
action: top
def top
    @cur_url = "/top"
    length = { :dur => 1, :intv => "Week" }

    if m = params[:length].to_s.match(/\A(\d+)([#{TOP_INTVS.keys.join}])\z/)
      length[:dur] = m[1].to_i
      length[:intv] = TOP_INTVS[m[2]]

      @cur_url << "/#{params[:length]}"
    end

    @stories, @show_more = get_from_cache(top: true, length: length) {
      paginate stories.top(length)
    }

    if length[:dur] > 1
      @heading = @title = "Top Stories of the Past #{length[:dur]} " <<
        length[:intv] << "s"
    else
      @heading = @title = "Top Stories of the Past " << length[:intv]
    end

     if @cur_url == "/recent" 
 end 
 @cur_url == "/hidden" ? "show_hidden" : "" 
  story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @page && @page > 1 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page == 2 ? "" : "page/#{@page - 1}" 
 @page - 1 
 end 
 if @show_more 
 if @page && @page > 1 
 end 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page + 1 
 @page + 1 
 end 

  end
----------------------
controller: home
action: tagged
def tagged
    @tag = Tag.where(:tag => params[:tag]).first!

    @stories, @show_more = get_from_cache(tag: @tag) {
      paginate stories.tagged(@tag)
    }

    @heading = @title = @tag.description.blank?? @tag.tag : @tag.description
    @cur_url = tag_url(@tag.tag)

    @rss_link = { :title => "RSS 2.0 - Tagged #{@tag.tag} (#{@tag.description})",
      :href => "/t/#{@tag.tag}.rss" }

    respond_to do |format|
      format.html {  if @cur_url == "/recent" 
 end 
 @cur_url == "/hidden" ? "show_hidden" : "" 
  story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @page && @page > 1 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page == 2 ? "" : "page/#{@page - 1}" 
 @page - 1 
 end 
 if @show_more 
 if @page && @page > 1 
 end 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page + 1 
 @page + 1 
 end 
 }
      format.rss {  coder = HTMLEntities.new 
 Rails.application.name 
 @title.present? ?
      ": " + h(@title) : "" 
 @title 
 Rails.application.root_url + (@newest ? "newest" : "") 
 @stories.each do |story| 
 raw coder.encode(story.title, :decimal) 
 story.url_or_comments_url 
 story.short_id_url 
 story.user.username 
 story.created_at.rfc2822 
 story.comments_url 
 raw coder.encode(story.markeddown_description, :decimal) 
 if story.url.present? 
 raw coder.encode("<p>" +
              link_to("Comments", story.comments_url) + "</p>", :decimal) 
 end 
 story.taggings.each do |tagging| 
 tagging.tag.tag 
 end 
 end 
 }
      format.json { render :json => @stories }
    end
  end
----------------------
controller: home
action: recent
def recent
    @stories, @show_more = get_from_cache(recent: true) {
      scope = if page == 1
        stories.recent
      else
        stories.newest
      end
      paginate scope
    }

    @heading = @title = "Recent Stories"
    @cur_url = "/recent"

    # our content changes every page load, so point at /newest.rss to be stable
    @rss_link = { :title => "RSS 2.0 - Newest Items",
      :href => "/newest.rss#{@user ? "?token=#{@user.rss_token}" : ""}" }

     if @cur_url == "/recent" 
 end 
 @cur_url == "/hidden" ? "show_hidden" : "" 
  story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @page && @page > 1 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page == 2 ? "" : "page/#{@page - 1}" 
 @page - 1 
 end 
 if @show_more 
 if @page && @page > 1 
 end 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page + 1 
 @page + 1 
 end 

  end
----------------------
controller: home
action: newest_by_user
def newest_by_user
    by_user = User.where(:username => params[:user]).first!

    @stories, @show_more = get_from_cache(by_user: by_user) {
      paginate stories.newest_by_user(by_user)
    }

    @heading = @title = "Newest Stories by #{by_user.username}"
    @cur_url = "/newest/#{by_user.username}"

    @newest = true
    @for_user = by_user.username

     if @cur_url == "/recent" 
 end 
 @cur_url == "/hidden" ? "show_hidden" : "" 
  story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @page && @page > 1 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page == 2 ? "" : "page/#{@page - 1}" 
 @page - 1 
 end 
 if @show_more 
 if @page && @page > 1 
 end 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page + 1 
 @page + 1 
 end 

  end
----------------------
controller: home
action: newest
def newest
    @stories, @show_more = get_from_cache(newest: true) {
      paginate stories.newest
    }

    @heading = @title = "Newest Stories"
    @cur_url = "/newest"

    @rss_link = { :title => "RSS 2.0 - Newest Items",
      :href => "/newest.rss#{@user ? "?token=#{@user.rss_token}" : ""}" }

    respond_to do |format|
      format.html {  if @cur_url == "/recent" 
 end 
 @cur_url == "/hidden" ? "show_hidden" : "" 
  story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @page && @page > 1 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page == 2 ? "" : "page/#{@page - 1}" 
 @page - 1 
 end 
 if @show_more 
 if @page && @page > 1 
 end 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page + 1 
 @page + 1 
 end 
 }
      format.rss {
        if @user && params[:token].present?
          @title += " - Private feed for #{@user.username}"
        end

         coder = HTMLEntities.new 
 Rails.application.name 
 @title.present? ?
      ": " + h(@title) : "" 
 @title 
 Rails.application.root_url + (@newest ? "newest" : "") 
 @stories.each do |story| 
 raw coder.encode(story.title, :decimal) 
 story.url_or_comments_url 
 story.short_id_url 
 story.user.username 
 story.created_at.rfc2822 
 story.comments_url 
 raw coder.encode(story.markeddown_description, :decimal) 
 if story.url.present? 
 raw coder.encode("<p>" +
              link_to("Comments", story.comments_url) + "</p>", :decimal) 
 end 
 story.taggings.each do |tagging| 
 tagging.tag.tag 
 end 
 end 

      }
      format.json { render :json => @stories }
    end
  end
----------------------
controller: home
action: index
def index
    @stories, @show_more = get_from_cache(hottest: true) {
      paginate stories.hottest
    }

    @rss_link ||= { :title => "RSS 2.0",
      :href => "/rss#{@user ? "?token=#{@user.rss_token}" : ""}" }
    @comments_rss_link ||= { :title => "Comments - RSS 2.0",
      :href => "/comments.rss#{@user ? "?token=#{@user.rss_token}" : ""}" }

    @heading = @title = ""
    @cur_url = "/"

    respond_to do |format|
      format.html {  if @cur_url == "/recent" 
 end 
 @cur_url == "/hidden" ? "show_hidden" : "" 
  story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @page && @page > 1 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page == 2 ? "" : "page/#{@page - 1}" 
 @page - 1 
 end 
 if @show_more 
 if @page && @page > 1 
 end 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page + 1 
 @page + 1 
 end 
 }
      format.rss {
        if @user && params[:token].present?
          @title = "Private feed for #{@user.username}"
        end

         coder = HTMLEntities.new 
 Rails.application.name 
 @title.present? ?
      ": " + h(@title) : "" 
 @title 
 Rails.application.root_url + (@newest ? "newest" : "") 
 @stories.each do |story| 
 raw coder.encode(story.title, :decimal) 
 story.url_or_comments_url 
 story.short_id_url 
 story.user.username 
 story.created_at.rfc2822 
 story.comments_url 
 raw coder.encode(story.markeddown_description, :decimal) 
 if story.url.present? 
 raw coder.encode("<p>" +
              link_to("Comments", story.comments_url) + "</p>", :decimal) 
 end 
 story.taggings.each do |tagging| 
 tagging.tag.tag 
 end 
 end 

      }
      format.json { render :json => @stories }
    end
  end
----------------------
controller: home
action: hidden
def hidden
    @stories, @show_more = get_from_cache(hidden: true) {
      paginate stories.hidden
    }

    @heading = @title = "Hidden Stories"
    @cur_url = "/hidden"

     if @cur_url == "/recent" 
 end 
 @cur_url == "/hidden" ? "show_hidden" : "" 
  story.short_id 
 story.short_id 
 story.vote && story.vote[:vote] == 1 ? "upvoted" : "" 
 story.vote && story.vote[:vote] == -1 ? "downvoted" : "" 
 story.score <= -1 ? "negative_1" : "" 
 story.score <= -3 ? "negative_3" : "" 
 story.score <= -5 ? "negative_5" : "" 
 story.is_hidden_by_cur_user ? "hidden" : "" 
 story.is_expired? ? "expired" : "" 
 if @user 
 else 
 link_to "", login_path, :class => "upvoter" 
 end 
 story.score 
 if story.can_be_seen_by_user?(@user) 
 story.url_or_comments_path 

          break_long_words(story.title) 
 end 
 if story.is_gone? 
 story.is_moderated? ? "moderator" :
          "original submitter" 
 end 
 if story.markeddown_description.present? 
 story.comments_path 
 end 
 if story.can_be_seen_by_user?(@user) 
 story.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if story.domain.present? 
 story.domain_search_url 

          break_long_words(story.domain) 
 end 
 if defined?(single_story) && single_story 
 story.merged_stories.each do |ms| 
 ms.url_or_comments_path 

              break_long_words(ms.title) 
 ms.sorted_taggings.each do |tagging| 
 tag_path(tagging.tag.tag) 
 tagging.tag.css_class 
 tagging.tag.description 
 tagging.tag.tag 
 end 
 if ms.domain.present? 
 ms.domain_search_url 

              break_long_words(ms.domain) 
 end 
 if @user && @user.show_avatars? 
 ms.user.username 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(16) 
 ms.user.avatar_url(32) 
 end 
 if story.user_is_author? 
 else 
 end 
 ms.user.username 

              ms.html_class_for_user 
 ms.user.username 
 time_ago_in_words_label(ms.created_at, :strip_about => true) 
 end 
 end 
 end 
 if !(defined?(single_story) && single_story) && @user &&
    @user.show_story_previews? 
 if (sc = story.description_or_story_cache(500)).present? 
 break_long_words(sc) 
 end 
 end 
 if @user && @user.show_avatars? 
 story.user.username 
 story.user.avatar_url(16) 
 story.user.avatar_url(16) 
 story.user.avatar_url(32) 
 end 
 if story.previewing 
 if story.user_is_author? 
 else 
 end 
 story.html_class_for_user 

          story.user.username 
 else 
 if story.user_is_author? 
 else 
 end 
 story.user.username 

          story.html_class_for_user 
 story.user.username 
 time_ago_in_words_label(story.created_at, :strip_about => true) 
 if story.is_editable_by_user?(@user) 
 edit_story_path(story.short_id) 
 if story.is_gone? && story.is_undeletable_by_user?(@user) 
 link_to "undelete", story_undelete_path(story.short_id),
              :method => :post, :data => {
              :confirm => "Are you sure you want to undelete this story?" } 
 elsif !story.is_gone? 
 if story.user_id != @user.try(:id) &&
            @user.try(:is_moderator?) 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :class => "mod_story_link" 
 else 
 link_to "delete", story_path(story.short_id),
                :method => :delete, :data => {
                :confirm => "Are you sure you want to delete this story?" } 
 end 
 end 
 end 
 if story.can_have_suggestions_from_user?(@user) 
 link_to "suggest", story_suggest_path(story.short_id),
            :class => "suggester" 
 end 
 if !story.is_gone? && @user 
 if @user && story.vote && story.vote[:vote] == -1 

              Vote::STORY_REASONS[story.vote[:reason]].to_s.downcase 
 elsif @user && @user.can_downvote?(story) 
 end 
 if story.is_hidden_by_cur_user 
 link_to "unhide", story_unhide_path(story.short_id),
              :class => "hider" 
 else 
 link_to "hide", story_hide_path(story.short_id),
              :class => "hider" 
 end 
 if defined?(single_story) && single_story && story.hider_count > 0 
 pluralize(story.hider_count, "user") 
 end 
 end 
 if !story.is_gone? && (@user || story.comments_count > 0) 
 story.comments_path 
 story.comments_count == 0 ?
              "discuss" : "#{story.comments_count} comment" <<
              (story.comments_count == 1 ? "" : "s") 
 end 
 if defined?(single_story) && single_story &&
        ((story.downvotes > 0 && @user && @user.is_moderator?) ||
        (story.downvotes >= 3 || story.score <= 0)) 
 story.vote_summary_for(@user).downcase 
 end 
 end 
 story.comments_count == 0 ? "zero" : "" 
 story.comments_path 
 story.comments_count 
 
 if @page && @page > 1 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page == 2 ? "" : "page/#{@page - 1}" 
 @page - 1 
 end 
 if @show_more 
 if @page && @page > 1 
 end 
 @cur_url 
 @cur_url == "/" ? "" : "/" 

      @page + 1 
 @page + 1 
 end 

  end
----------------------
controller: home
action: privacy
def privacy
    begin
      render :action => "privacy"
    rescue
      render :text => "<div class=\"box wide\">" <<
        "You apparently have no privacy." <<
        "</div>", :layout => "application"
    end
  end
----------------------
controller: home
action: chat
def chat
    render :action => "chat"
  end
----------------------
controller: home
action: about
def about
    begin
      render :action => "about"
    rescue
      render :text => "<div class=\"box wide\">" <<
        "A mystery." <<
        "</div>", :layout => "application"
    end
  end
----------------------
controller: invitations
action: delete_request
def delete_request
    if !@user.is_moderator?
      return redirect_to "/invitations"
    end

    if !(ir = InvitationRequest.where(:code => params[:code].to_s).first)
      flash[:error] = "Invalid or expired invitation request"
      return redirect_to "/invitations"
    end

    ir.destroy!
    flash[:success] = "Successfully deleted invitation request from " <<
      ir.name.to_s << "."

    return redirect_to "/invitations"
  end
----------------------
controller: invitations
action: send_for_request
def send_for_request
    if !(ir = InvitationRequest.where(:code => params[:code].to_s).first)
      flash[:error] = "Invalid or expired invitation request"
      return redirect_to "/invitations"
    end

    i = Invitation.new
    i.user_id = @user.id
    i.email = ir.email

    i.save!
    i.send_email
    ir.destroy!
    flash[:success] = "Successfully e-mailed invitation to " <<
      ir.name.to_s << "."

    return redirect_to "/invitations"
  end
----------------------
controller: invitations
action: create_by_request
def create_by_request
    if Rails.application.allow_invitation_requests?
      @invitation_request = InvitationRequest.new(
        params.require(:invitation_request).permit(:name, :email, :memo))

      @invitation_request.ip_address = request.remote_ip

      if @invitation_request.save
        flash[:success] = "You have been e-mailed a confirmation to " <<
          params[:invitation_request][:email].to_s << "."
        return redirect_to "/invitations/request"
      else
        render :action => :build
      end
    else
      return redirect_to "/login"
    end
  end
----------------------
controller: invitations
action: create
def create
    i = Invitation.new
    i.user_id = @user.id
    i.email = params[:email]
    i.memo = params[:memo]

    begin
      i.save!
      i.send_email
      flash[:success] = "Successfully e-mailed invitation to " <<
        params[:email].to_s << "."
    rescue
      flash[:error] = "Could not send invitation, verify the e-mail " <<
        "address is valid."
    end

    if params[:return_home]
      return redirect_to "/"
    else
      return redirect_to "/settings"
    end
  end
----------------------
controller: invitations
action: confirm_email
def confirm_email
    if !(ir = InvitationRequest.where(:code => params[:code].to_s).first)
      flash[:error] = "Invalid or expired invitation request"
      return redirect_to "/invitations/request"
    end

    ir.is_verified = true
    ir.save!

    flash[:success] = "Your invitation request has been validated and " <<
      "will now be shown to other logged-in users."
    return redirect_to "/invitations/request"
  end
----------------------
controller: invitations
action: index
def index
    @invitation_requests = InvitationRequest.where(:is_verified => true)
  end
----------------------
controller: invitations
action: build
def build
    if Rails.application.allow_invitation_requests?
      @invitation_request = InvitationRequest.new
    else
      flash[:error] = "Public invitation requests are not allowed."
      return redirect_to "/login"
    end
  end
----------------------
controller: application
action: find_user_from_rss_token
def find_user_from_rss_token
    if !@user && request[:format] == "rss" && params[:token].to_s.present?
      @user = User.where(:rss_token => params[:token].to_s).first
    end
  end
----------------------
controller: application
action: user_is_spider?
def user_is_spider?
    ua = request.env["HTTP_USER_AGENT"].to_s
    (ua == "" || ua.match(/(Google|bing)bot/))
  end
----------------------
controller: application
action: tags_filtered_by_cookie
def tags_filtered_by_cookie
    @_tags_filtered ||= Tag.where(
      :tag => cookies[TAG_FILTER_COOKIE].to_s.split(",")
    )
  end
----------------------
controller: application
action: require_logged_in_user_or_400
def require_logged_in_user_or_400
    if @user
      true
    else
      render :text => "not logged in", :status => 400
      return false
    end
  end
----------------------
controller: application
action: require_logged_in_moderator
def require_logged_in_moderator
    require_logged_in_user

    if @user
      if @user.is_moderator?
        true
      else
        flash[:error] = "You are not authorized to access that resource."
        return redirect_to "/"
      end
    end
  end
----------------------
controller: application
action: require_logged_in_user
def require_logged_in_user
    if @user
      true
    else
      if request.get?
        session[:redirect_to] = request.original_fullpath
      end

      redirect_to "/login"
    end
  end
----------------------
controller: application
action: increase_traffic_counter
def increase_traffic_counter
    @traffic = 1.0

    if user_is_spider? || [ "json", "rss" ].include?(params[:format])
      return true
    end

    Keystore.transaction do
      now_i = Time.now.to_i
      date_kv = Keystore.find_or_create_key_for_update("traffic:date", now_i)
      traffic_kv = Keystore.find_or_create_key_for_update("traffic:hits", 0)

      # increment traffic counter on each request
      traffic = traffic_kv.value.to_i + 100
      # every second, decrement traffic by some amount
      traffic -= (100.0 * (now_i - date_kv.value) * TRAFFIC_DECREMENTER).to_i
      # clamp to 100, 1000
      traffic = [ [ 100, traffic ].max, 10000 ].min

      @traffic = traffic * 0.01

      traffic_kv.value = traffic
      traffic_kv.save!

      date_kv.value = now_i
      date_kv.save!

      Rails.logger.info "  Traffic level: #{@traffic} (#{traffic})"
    end

    true
  end
----------------------
controller: application
action: authenticate_user
def authenticate_user
    if session[:u] &&
    (user = User.where(:session_token => session[:u].to_s).first) &&
    user.is_active?
      @user = user
      Rails.logger.info "  Logged in as user #{@user.id} (#{@user.username})"
    end

    true
  end
----------------------
controller: settings
action: user_params
def user_params
    params.require(:user).permit(
      :username, :email, :password, :password_confirmation, :about,
      :email_replies, :email_messages, :email_mentions,
      :pushover_replies, :pushover_messages, :pushover_mentions,
      :mailing_list_mode, :show_avatars, :show_story_previews,
      :show_submitted_story_threads
    )
  end
----------------------
controller: settings
action: update
def update
    @edit_user = @user.clone

    if @edit_user.update_attributes(user_params)
      flash.now[:success] = "Successfully updated settings."
      @user = @edit_user
    end

     @user.username 
 form_for @edit_user, :url => settings_path, :method => :post,
  :html => { :id => "edit_user" } do |f| 
 error_messages_for f.object 
 f.label :username, "Username:", :class => "required" 
 f.text_field :username, :size => 15 
 User.username_regex 
 f.label :password, "New Password:", :class => "required" 
 f.password_field :password, :size => 40, :autocomplete => "off" 
 f.label :password_confirmation, "Confirm Password:",
        :class => "required" 
 f.password_field :password_confirmation, :size => 40,
        :autocomplete => "off" 
 f.label :email, "E-mail Address:", :class => "required" 
 f.text_field :email, :size => 40 
 f.label :about, "About:", :class => "required" 
 f.text_area :about, :size => "100x5", :style => "width: 600px;" 
  if defined?(allow_images) && allow_images 
 end 
 
 f.submit "Save Account Settings" 
 f.label :pushover_user_key,
        raw("<a href=\"https://pushover.net/\">Pushover</a>:"),
        :class => "required" 
 link_to((f.object.pushover_user_key.present??
        "Manage Pushover Subscription" : "Subscribe With Pushover"),
        "/settings/pushover", :class => "pushover_button", :method => :post) 
 f.label :email_replies, "Receive E-mail:", :class => "required" 
 f.check_box :email_replies 
 f.label :pushover_replies, "Receive Pushover Alert:",
        :class => "required" 
 f.check_box :pushover_replies 
 f.label :email_mentions, "Receive E-mail:", :class => "required" 
 f.check_box :email_mentions 
 f.label :pushover_mentions, "Receive Pushover Alert:",
        :class => "required" 
 f.check_box :pushover_mentions 
 f.label :email_messages, "Receive E-mail:", :class => "required" 
 f.check_box :email_messages 
 f.label :pushover_messages, "Receive Pushover Alert:",
        :class => "required" 
 f.check_box :pushover_messages 
 f.label :show_submitted_story_threads,
        "Show in Your Threads:", :class => "required" 
 f.check_box :show_submitted_story_threads 
 f.label :mailing_list_mode, "Receive List E-mails:",
        :class => "required" 
 f.select :mailing_list_mode, [ [ "No e-mails", 0 ],
        [ "All stories and comments", 1 ], [ "Only stories", 2 ] ] 
 Rails.application.shortname 

        @edit_user.mailing_list_token 
 Rails.application.domain 
 f.label :show_story_previews, "Show Story Previews:",
        :class => "required" 
 f.check_box :show_story_previews 
 f.label :show_avatars, "Show User Avatars:", :class => "required" 
 f.check_box :show_avatars 
 f.submit "Save All Settings" 
 end 
 form_for @edit_user, :url => delete_account_path, :method => :post,
  :html => { :id => "delete_user" } do |f| 
 f.label :password, "Verify Password:", :class => "required" 
 f.password_field :password, :size => 40, :autocomplete => "off" 
 f.submit "Yes, Delete My Account" 
 end 
  form_tag "/invitations", :method => :post do |f| 
 if defined?(return_home) && return_home 
 hidden_field_tag :return_home, 1 
 end 
 label_tag :email, "E-mail Address:", :class => "required" 
 text_field_tag :email, "", :size => 30, :autocomplete => "off" 
 label_tag :memo, "Memo to User:", :class => "required" 
 text_field_tag :memo, "", :size => 60 
 submit_tag "Send Invitation" 
 end 
 

  end
----------------------
controller: settings
action: pushover_callback
def pushover_callback
    if !session[:pushover_rand].to_s.present?
      flash[:error] = "No random token present in session"
      return redirect_to "/settings"
    end

    if !params[:rand].to_s.present?
      flash[:error] = "No random token present in URL"
      return redirect_to "/settings"
    end

    if params[:rand].to_s != session[:pushover_rand].to_s
      raise "rand param #{params[:rand].inspect} != " <<
        session[:pushover_rand].inspect
    end

    @user.pushover_user_key = params[:pushover_user_key].to_s
    @user.save!

    if @user.pushover_user_key.present?
      flash[:success] = "Your account is now setup for Pushover notifications."
    else
      flash[:success] = "Your account is no longer setup for Pushover " <<
        "notifications."
    end

    return redirect_to "/settings"
  end
----------------------
controller: settings
action: pushover
def pushover
    if !Pushover.SUBSCRIPTION_CODE
      flash[:error] = "This site is not configured for Pushover"
      return redirect_to "/settings"
    end

    session[:pushover_rand] = SecureRandom.hex

    return redirect_to Pushover.subscription_url({
      :success => "#{Rails.application.root_url}settings/pushover_callback?" <<
        "rand=#{session[:pushover_rand]}",
      :failure => "#{Rails.application.root_url}settings/",
    })
  end
----------------------
controller: settings
action: delete_account
def delete_account
    if @user.try(:authenticate, params[:user][:password].to_s)
      @user.delete!
      reset_session
      flash[:success] = "Your account has been deleted."
      return redirect_to "/"
    end

    flash[:error] = "Your password could not be verified."
    return redirect_to settings_path
  end
----------------------
controller: settings
action: index
def index
    @title = "Account Settings"

    @edit_user = @user.dup
  end
----------------------
controller: login
action: set_new_password
def set_new_password
    @title = "Reset Password"

    if (m = params[:token].to_s.match(/^(\d+)-/)) &&
    (Time.now - Time.at(m[1].to_i)) < 24.hours
      @reset_user = User.where(:password_reset_token => params[:token].to_s).first
    end

    if @reset_user && !@reset_user.is_banned?
      if params[:password].present?
        @reset_user.password = params[:password]
        @reset_user.password_confirmation = params[:password_confirmation]
        @reset_user.password_reset_token = nil

        # this will get reset upon save
        @reset_user.session_token = nil

        if !@reset_user.is_active? && !@reset_user.is_banned?
          @reset_user.deleted_at = nil
        end

        if @reset_user.save && @reset_user.is_active?
          session[:u] = @reset_user.session_token
          return redirect_to "/"
        else
          flash[:error] = "Could not reset password."
        end
      end
    else
      flash[:error] = "Invalid reset token.  It may have already been " <<
        "used or you may have copied it incorrectly."
      return redirect_to forgot_password_path
    end
  end
----------------------
controller: login
action: reset_password
def reset_password
    @found_user = User.where("email = ? OR username = ?", params[:email].to_s,
      params[:email].to_s).first

    if !@found_user
      flash.now[:error] = "Invalid e-mail address or username."
      return forgot_password
    end

    @found_user.initiate_password_reset_for_ip(request.remote_ip)

    flash.now[:success] = "Password reset instructions have been e-mailed " <<
      "to you."
    return index
  end
----------------------
controller: login
action: forgot_password
def forgot_password
    @title = "Reset Password"
     form_tag reset_password_path do 
 label_tag :email, "E-mail or Username:" 
 text_field_tag :email, "", :size => 30 
 submit_tag "Reset Password" 
 end 

  end
----------------------
controller: login
action: login
def login
    if params[:email].to_s.match(/@/)
      user = User.where(:email => params[:email]).first
    else
      user = User.where(:username => params[:email]).first
    end

    begin
      if !user
        raise "no user"
      end

      if !user.try(:authenticate, params[:password].to_s)
        raise "authentication failed"
      end

      if user.is_banned?
        raise "user is banned"
      end

      if !user.is_active?
        user.undelete!
        flash[:success] = "Your account has been reactivated and your " <<
          "unmoderated comments have been undeleted."
      end

      session[:u] = user.session_token

      if !user.password_digest.to_s.match(/^\$2a\$#{BCrypt::Engine::DEFAULT_COST}\$/)
        user.password = user.password_confirmation = params[:password].to_s
        user.save!
      end

      if (rd = session[:redirect_to]).present?
        session.delete(:redirect_to)
        return redirect_to rd
      elsif params[:referer].present?
        begin
          ru = URI.parse(params[:referer])
          if ru.host == Rails.application.domain
            return redirect_to ru.to_s
          end
        rescue => e
          Rails.logger.error "error parsing referer: #{e}"
        end
      end

      return redirect_to "/"
    rescue
    end

    flash.now[:error] = "Invalid e-mail address and/or password."
    @referer = params[:referer]
    index
  end
----------------------
controller: login
action: index
def index
    @title = "Login"
    @referer ||= request.referer
     form_tag login_path do 
 label_tag :email, "E-mail or Username:" 
 text_field_tag :email, "", :size => 30, :autofocus => "autofocus" 
 label_tag :password, "Password:" 
 password_field_tag :password, "", :size => 30 
 submit_tag "Login" 
 link_to "Reset your password", forgot_password_path 
 if Rails.application.allow_invitation_requests? 
 else 
 end 
 if @referer.present? 
 hidden_field_tag :referer, @referer 
 end 
 end 

  end
----------------------
controller: login
action: logout
def logout
    if @user
      reset_session
    end

    redirect_to "/"
  end
----------------------
controller: tags
action: index
def index
    @cur_url = "/tags"
    @title = "Tags"

    @tags = Tag.all_with_story_counts_for(nil)

    respond_to do |format|
      format.html {  max_size = @tags.map{|t| t.stories_count }.max 
 @tags.each do |tag| 
 mod = (max_size.to_f / tag.stories_count.to_f) 
 link_to tag.tag, tag_path(tag), :class => tag.css_class,
      :style => "text-decoration: none; vertical-align: middle; " <<
      "font-size: #{((52 / (mod + 1)) + 8).ceil}pt; line-height: 1.5em;" 
 end 
 }
      format.json { render :json => @tags }
    end
  end
----------------------
