SET IRMethod, name = get
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 1, opt: 0, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		key = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		line_num(;n: 6)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = copy({:'key'=>key})		--org.jruby.ir.instructions.CopyInstr(	key[2.5 ] ) 
		%v_4 = call_1o(%self, %v_3 ;n:where, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[2.0 ] %v_3[2.7 ] ) 
		%v_5 = call_0o(%v_4 ;n:first, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_4[2.8 ] ) 
		return(%v_5)		--org.jruby.ir.instructions.ReturnInstr(	%v_5[2.9 ] ) 
PRINT info for BB 3:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = value_for
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 1, opt: 0, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		key = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		line_num(;n: 10)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = copy({:'key'=>key})		--org.jruby.ir.instructions.CopyInstr(	key[2.5 ] ) 
		%v_4 = call_1o(%self, %v_3 ;n:where, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[2.0 ] %v_3[2.7 ] ) 
		%v_5 = call_0o(%v_4 ;n:first, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_4[2.8 ] ) 
		%v_6 = call_1o(%v_5, :'value' ;n:try, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%v_5[2.9 ] ) 
		return(%v_6)		--org.jruby.ir.instructions.ReturnInstr(	%v_6[2.10 ] ) 
PRINT info for BB 3:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = put
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:9, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit: 
	outgoing edges:3, 4, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 2, opt: 0, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		key = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		value = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		line_num(;n: 14)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = search_const(scope<1> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%v_4 = call_0o(%v_3 ;n:connection, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_3[2.8 ] ) 
		%v_5 = call_0o(%v_4 ;n:adapter_name, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_4[2.9 ] ) 
		%v_6 = copy("SQLite")		--org.jruby.ir.instructions.CopyInstr(	) 
		%v_7 = call_1o(%v_5, %v_6 ;n:==, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%v_5[2.10 ] %v_6[2.11 ] ) 
		b_false(LBL_0:35, %v_7)		--org.jruby.ir.instructions.BFalseInstr(	%v_7[2.12 ] ) 
PRINT info for BB 3:
	Vars Live on Entry: 
	Vars Live on Exit:  0 4 5		
	outgoing edges:8, 
	Instructions:
		line_num(;n: 15)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_8 = search_const(scope<1> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%v_9 = call_0o(%v_8 ;n:connection, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_8[3.1 ] ) 
		%v_10 = copy("INSERT OR REPLACE INTO ")		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 16)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_11 = search_const(scope<1> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%v_12 = call_0o(%v_11 ;n:table_name, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_11[3.5 ] ) 
		%v_13 = copy(" (`key`, `value`) VALUES ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%v_14 = build_compound_string(#{%v_12}, %v_13)		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%v_12[3.6 ] %v_13[3.7 ] ) 
		%v_15 = call_1o(%v_10, %v_14 ;n:<<, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%v_10[3.3 ] %v_14[3.8 ] ) 
		%v_16 = copy("(")		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 17)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_17 = call_1o(%self, key ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[2.0 ] key[2.5 ] ) 
		%v_18 = copy(", ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%v_19 = call_1o(%self, value ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[3.12 2.0 ] value[2.6 ] ) 
		%v_20 = copy(")")		--org.jruby.ir.instructions.CopyInstr(	) 
		%v_21 = build_compound_string(%v_16, #{%v_17}, %v_18, #{%v_19}, %v_20)		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%v_16[3.10 ] %v_17[3.12 ] %v_18[3.13 ] %v_19[3.14 ] %v_20[3.15 ] ) 
		%v_22 = call_1o(%v_15, %v_21 ;n:<<, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%v_15[3.9 ] %v_21[3.16 ] ) 
		%v_23 = call_1o(%v_9, %v_22 ;n:execute, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%v_9[3.2 ] %v_22[3.17 ] ) 
		jump(LBL_1:77)		--org.jruby.ir.instructions.JumpInstr(	) 
PRINT info for BB 4:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit:  0 4 5		
	outgoing edges:5, 6, 
	Instructions:
		line_num(;n: 18)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_24 = search_const(scope<1> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%v_25 = call_0o(%v_24 ;n:connection, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_24[4.1 ] ) 
		%v_26 = call_0o(%v_25 ;n:adapter_name, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_25[4.2 ] ) 
		%v_27 = copy(RE:|Mysql|RegexpOptions(kcode: NONE, kcodeDefault))		--org.jruby.ir.instructions.CopyInstr(	) 
		%v_28 = match(%v_26, RE:|Mysql|RegexpOptions(kcode: NONE, kcodeDefault) ;n:=~, t:NO, cl:false)		--org.jruby.ir.instructions.MatchInstr(	%v_26[4.3 ] ) 
		b_false(LBL_2:66, %v_28)		--org.jruby.ir.instructions.BFalseInstr(	%v_28[4.5 ] ) 
PRINT info for BB 5:
	Vars Live on Entry:  50		
	Vars Live on Exit:  0 4 5		
	outgoing edges:7, 
	Instructions:
		line_num(;n: 19)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_29 = search_const(scope<1> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%v_30 = call_0o(%v_29 ;n:connection, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_29[5.1 ] ) 
		%v_31 = copy("INSERT INTO ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%v_32 = search_const(scope<1> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%v_33 = call_0o(%v_32 ;n:table_name, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_32[5.4 ] ) 
		%v_34 = copy(" (")		--org.jruby.ir.instructions.CopyInstr(	) 
		%v_35 = build_compound_string(%v_31, #{%v_33}, %v_34)		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%v_31[5.3 ] %v_33[5.5 ] %v_34[5.6 ] ) 
		%v_36 = copy("`key`, `value`) VALUES (")		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 20)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_37 = call_1o(%self, key ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[2.0 ] key[2.5 ] ) 
		%v_38 = copy(", ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%v_39 = call_1o(%self, value ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[5.10 2.0 ] value[2.6 ] ) 
		%v_40 = copy(") ON DUPLICATE KEY ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%v_41 = build_compound_string(%v_36, #{%v_37}, %v_38, #{%v_39}, %v_40)		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%v_36[5.8 ] %v_37[5.10 ] %v_38[5.11 ] %v_39[5.12 ] %v_40[5.13 ] ) 
		%v_42 = call_1o(%v_35, %v_41 ;n:+, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%v_35[5.7 ] %v_41[5.14 ] ) 
		%v_43 = copy("UPDATE `value` = ")		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 21)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_44 = call_1o(%self, value ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[5.10 5.12 2.0 ] value[2.6 ] ) 
		%v_45 = build_compound_string(%v_43, #{%v_44})		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%v_43[5.16 ] %v_44[5.18 ] ) 
		%v_46 = call_1o(%v_42, %v_45 ;n:+, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%v_42[5.15 ] %v_45[5.19 ] ) 
		%v_47 = call_1o(%v_30, %v_46 ;n:execute, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%v_30[5.2 ] %v_46[5.20 ] ) 
		jump(LBL_3:75)		--org.jruby.ir.instructions.JumpInstr(	) 
PRINT info for BB 6:
	Vars Live on Entry:  50		
	Vars Live on Exit:  0 4 5		
	outgoing edges:7, 
	Instructions:
		line_num(;n: 23)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_48 = call(%self, key, value ;n:find_or_create_key_for_update, t:NO, cl:false)		--org.jruby.ir.instructions.CallInstr(	%self[2.0 ] key[2.5 ] value[2.6 ] ) 
		kv = copy(%v_48)		--org.jruby.ir.instructions.CopyInstr(	%v_48[6.1 ] ) 
		line_num(;n: 24)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		attr_assign(%v_48, value ;n:value=, t:UN, cl:false)		--org.jruby.ir.instructions.specialized.OneArgOperandAttrAssignInstr(	%v_48[6.1 ] value[2.6 ] ) #<%v_48>#	-- [PUT:%v_48].value 
		line_num(;n: 25)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_49 = call_0o(kv ;n:save!, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	kv[6.2 ] ) 
		%v_47 = copy(%v_49)		--org.jruby.ir.instructions.CopyInstr(	%v_49[6.6 ] ) 
PRINT info for BB 7:
	Vars Live on Entry: 
	Vars Live on Exit:  50		
	outgoing edges:8, 
	Instructions:
		%v_23 = copy(%v_47)		--org.jruby.ir.instructions.CopyInstr(	%v_47[6.7 5.21 ] ) 
PRINT info for BB 8:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:9, 
	Instructions:
		line_num(;n: 29)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		return(true)		--org.jruby.ir.instructions.ReturnInstr(	) 
PRINT info for BB 9:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = increment_value_for
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:5, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit: 
	outgoing edges:3, 4, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 1, opt: 1, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		key = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		amount = recv_opt_arg(;index:0, req: 1, pre: 1)		--org.jruby.ir.instructions.ReceiveOptArgInstr(	) 
		bne(LBL_0:10, amount, %undefined)		--org.jruby.ir.instructions.BNEInstr(	amount[2.6 ] ) 
PRINT info for BB 3:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit:  0 4		
	outgoing edges:4, 
	Instructions:
		amount = copy(Fixnum:1)		--org.jruby.ir.instructions.CopyInstr(	) 
PRINT info for BB 4:
	Vars Live on Entry: 
	Vars Live on Exit:  0 4 5		
	outgoing edges:5, 
	Instructions:
		line_num(;n: 32)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = call(%self, key, amount ;n:incremented_value_for, t:NO, cl:false)		--org.jruby.ir.instructions.CallInstr(	%self[2.0 ] key[2.5 ] amount[3.0 2.6 ] ) 
		return(%v_3)		--org.jruby.ir.instructions.ReturnInstr(	%v_3[4.1 ] ) 
PRINT info for BB 5:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = incremented_value_for
PRINT info for BB 1:
	Vars Live on Entry:  4 5		
	Vars Live on Exit:  4 5		
	outgoing edges:8, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit:  4 5		
	outgoing edges:4, 5, 6, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 1, opt: 1, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		key = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		amount = recv_opt_arg(;index:0, req: 1, pre: 1)		--org.jruby.ir.instructions.ReceiveOptArgInstr(	) 
		bne(LBL_0:12, amount, %undefined)		--org.jruby.ir.instructions.BNEInstr(	amount[2.6 ] ) 
PRINT info for BB 4:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit:  0 4		
	outgoing edges:5, 
	Instructions:
		amount = copy(Fixnum:1)		--org.jruby.ir.instructions.CopyInstr(	) 
PRINT info for BB 5:
	Vars Live on Entry:  4 5		
	Vars Live on Exit:  0 4 5		
	outgoing edges:6, 8, 
	Instructions:
		line_num(;n: 36)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = search_const(scope<1> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%v_4 = call(%v_3, %self:CLOSURE incremented_value_for_CLOSURE_1[./lobsters/models/keystore.rb:36] ;n:transaction, t:NO, cl:true(org.jruby.ir.operands.WrappedIRClosure))		--org.jruby.ir.instructions.CallInstr(	%v_3[5.1 ] %self[2.0 ] ) 
CLOSURE BEGIN: %self[2.0,] key[2.5,] amount[4.0,2.6,] kv[] 
PRINT info for BB 1:
	Vars Live on Entry:  19 33		
	Vars Live on Exit:  19 33		
	outgoing edges:12, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry:  0 19 33		
	Vars Live on Exit:  19 33		
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%cl_1_0 = load_frame_closure()		--org.jruby.ir.instructions.LoadFrameClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
PRINT info for BB 3:
	Vars Live on Entry:  0 19 33		
	Vars Live on Exit:  0 19 33		
	outgoing edges:4, 5, 10, 
	Instructions:
		line_num(;n: 37)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_3 = search_const(scope<2> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%cl_1_4 = call_0o(%cl_1_3 ;n:connection, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_3[3.1 ] ) 
		%cl_1_5 = call_0o(%cl_1_4 ;n:adapter_name, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_4[3.2 ] ) 
		%cl_1_6 = copy("SQLite")		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_7 = call_1o(%cl_1_5, %cl_1_6 ;n:==, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_5[3.3 ] %cl_1_6[3.4 ] ) 
		b_false(CL1_LBL_0:48, %cl_1_7)		--org.jruby.ir.instructions.BFalseInstr(	%cl_1_7[3.5 ] ) 
PRINT info for BB 4:
	Vars Live on Entry:  0 19 33		
	Vars Live on Exit:  0 19 33		
	outgoing edges:9, 10, 
	Instructions:
		line_num(;n: 38)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_8 = search_const(scope<2> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%cl_1_9 = call_0o(%cl_1_8 ;n:connection, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_8[4.1 ] ) 
		%cl_1_10 = copy("INSERT OR IGNORE INTO ")		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 39)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_11 = search_const(scope<2> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%cl_1_12 = call_0o(%cl_1_11 ;n:table_name, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_11[4.5 ] ) 
		%cl_1_13 = copy(" (`key`, `value`) VALUES ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_14 = build_compound_string(#{%cl_1_12}, %cl_1_13)		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%cl_1_12[4.6 ] %cl_1_13[4.7 ] ) 
		%cl_1_15 = call_1o(%cl_1_10, %cl_1_14 ;n:<<, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_10[4.3 ] %cl_1_14[4.8 ] ) 
		%cl_1_16 = copy("(")		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 40)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_17 = call_1o(%self, key ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[2.0 ] key[] ) 
		%cl_1_18 = copy(", 0)")		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_19 = build_compound_string(%cl_1_16, #{%cl_1_17}, %cl_1_18)		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%cl_1_16[4.10 ] %cl_1_17[4.12 ] %cl_1_18[4.13 ] ) 
		%cl_1_20 = call_1o(%cl_1_15, %cl_1_19 ;n:<<, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_15[4.9 ] %cl_1_19[4.14 ] ) 
		%cl_1_21 = call_1o(%cl_1_9, %cl_1_20 ;n:execute, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_9[4.2 ] %cl_1_20[4.15 ] ) 
		line_num(;n: 41)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_22 = search_const(scope<2> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%cl_1_23 = call_0o(%cl_1_22 ;n:connection, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_22[4.18 ] ) 
		%cl_1_24 = copy("UPDATE ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_25 = search_const(scope<2> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%cl_1_26 = call_0o(%cl_1_25 ;n:table_name, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_25[4.21 ] ) 
		%cl_1_27 = copy(" ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_28 = build_compound_string(%cl_1_24, #{%cl_1_26}, %cl_1_27)		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%cl_1_24[4.20 ] %cl_1_26[4.22 ] %cl_1_27[4.23 ] ) 
		%cl_1_29 = copy("SET `value` = `value` + ")		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 42)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_30 = call_1o(%self, amount ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[4.12 2.0 ] amount[] ) 
		%cl_1_31 = copy(" WHERE `key` = ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_32 = call_1o(%self, key ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[4.12 4.27 2.0 ] key[] ) 
		%cl_1_33 = build_compound_string(%cl_1_29, #{%cl_1_30}, %cl_1_31, #{%cl_1_32})		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%cl_1_29[4.25 ] %cl_1_30[4.27 ] %cl_1_31[4.28 ] %cl_1_32[4.29 ] ) 
		%cl_1_34 = call_1o(%cl_1_28, %cl_1_33 ;n:<<, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_28[4.24 ] %cl_1_33[4.30 ] ) 
		%cl_1_35 = call_1o(%cl_1_23, %cl_1_34 ;n:execute, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_23[4.19 ] %cl_1_34[4.31 ] ) 
		jump(CL1_LBL_1:96)		--org.jruby.ir.instructions.JumpInstr(	) 
PRINT info for BB 5:
	Vars Live on Entry:  0 19 33		
	Vars Live on Exit:  0 19 33		
	outgoing edges:6, 7, 10, 
	Instructions:
		line_num(;n: 43)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_36 = search_const(scope<2> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%cl_1_37 = call_0o(%cl_1_36 ;n:connection, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_36[5.1 ] ) 
		%cl_1_38 = call_0o(%cl_1_37 ;n:adapter_name, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_37[5.2 ] ) 
		%cl_1_39 = copy(RE:|Mysql|RegexpOptions(kcode: NONE, kcodeDefault))		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_40 = match(%cl_1_38, RE:|Mysql|RegexpOptions(kcode: NONE, kcodeDefault) ;n:=~, t:NO, cl:false)		--org.jruby.ir.instructions.MatchInstr(	%cl_1_38[5.3 ] ) 
		b_false(CL1_LBL_2:79, %cl_1_40)		--org.jruby.ir.instructions.BFalseInstr(	%cl_1_40[5.5 ] ) 
PRINT info for BB 6:
	Vars Live on Entry:  0 19 33 62		
	Vars Live on Exit:  0 19 33		
	outgoing edges:8, 10, 
	Instructions:
		line_num(;n: 44)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_41 = search_const(scope<2> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%cl_1_42 = call_0o(%cl_1_41 ;n:connection, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_41[6.1 ] ) 
		%cl_1_43 = copy("INSERT INTO ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_44 = search_const(scope<2> ;name: Keystore, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%cl_1_45 = call_0o(%cl_1_44 ;n:table_name, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_44[6.4 ] ) 
		%cl_1_46 = copy(" (")		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_47 = build_compound_string(%cl_1_43, #{%cl_1_45}, %cl_1_46)		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%cl_1_43[6.3 ] %cl_1_45[6.5 ] %cl_1_46[6.6 ] ) 
		%cl_1_48 = copy("`key`, `value`) VALUES (")		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 45)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_49 = call_1o(%self, key ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[2.0 ] key[] ) 
		%cl_1_50 = copy(", ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_51 = call_1o(%self, amount ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[6.10 2.0 ] amount[] ) 
		%cl_1_52 = copy(") ON DUPLICATE KEY ")		--org.jruby.ir.instructions.CopyInstr(	) 
		%cl_1_53 = build_compound_string(%cl_1_48, #{%cl_1_49}, %cl_1_50, #{%cl_1_51}, %cl_1_52)		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%cl_1_48[6.8 ] %cl_1_49[6.10 ] %cl_1_50[6.11 ] %cl_1_51[6.12 ] %cl_1_52[6.13 ] ) 
		%cl_1_54 = call_1o(%cl_1_47, %cl_1_53 ;n:+, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_47[6.7 ] %cl_1_53[6.14 ] ) 
		%cl_1_55 = copy("UPDATE `value` = `value` + ")		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 46)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_56 = call_1o(%self, amount ;n:q, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[6.10 6.12 2.0 ] amount[] ) 
		%cl_1_57 = build_compound_string(%cl_1_55, #{%cl_1_56})		--org.jruby.ir.instructions.BuildCompoundStringInstr(	%cl_1_55[6.16 ] %cl_1_56[6.18 ] ) 
		%cl_1_58 = call_1o(%cl_1_54, %cl_1_57 ;n:+, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_54[6.15 ] %cl_1_57[6.19 ] ) 
		%cl_1_59 = call_1o(%cl_1_42, %cl_1_58 ;n:execute, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_42[6.2 ] %cl_1_58[6.20 ] ) 
		jump(CL1_LBL_3:94)		--org.jruby.ir.instructions.JumpInstr(	) 
PRINT info for BB 7:
	Vars Live on Entry: 
	Vars Live on Exit:  0 19 33		
	outgoing edges:10, 12, 
	Instructions:
		line_num(;n: 48)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_60 = call(%self, key, Fixnum:0 ;n:find_or_create_key_for_update, t:NO, cl:false)		--org.jruby.ir.instructions.CallInstr(	%self[2.0 ] key[] ) 
		kv = copy(%cl_1_60)		--org.jruby.ir.instructions.CopyInstr(	%cl_1_60[7.1 ] ) 
		line_num(;n: 49)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_61 = call_0o(%cl_1_60 ;n:value, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_60[7.1 ] ) 
		%cl_1_62 = call_0o(%cl_1_61 ;n:to_i, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_61[7.4 ] ) 
		%cl_1_63 = call_1o(%cl_1_62, amount ;n:+, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_62[7.5 ] amount[] ) 
		attr_assign(kv, %cl_1_63 ;n:value=, t:UN, cl:false)		--org.jruby.ir.instructions.specialized.OneArgOperandAttrAssignInstr(	kv[7.2 ] %cl_1_63[7.6 ] ) #<kv>#	-- [PUT:kv].value 
		line_num(;n: 50)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_64 = call_0o(kv ;n:save!, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	kv[7.2 7.7 ] ) 
		line_num(;n: 51)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_65 = call_0o(kv ;n:value, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	kv[7.2 7.7 7.9 ] ) 
		check_for_lje(;maybe_lambda: false)		--org.jruby.ir.instructions.CheckForLJEInstr(	) 
		nonlocal_return(%cl_1_65 ;name: incremented_value_for)		--org.jruby.ir.instructions.NonlocalReturnInstr(	%cl_1_65[7.11 ] ) 
PRINT info for BB 8:
	Vars Live on Entry:  0 19 33		
	Vars Live on Exit:  0 19 33 62		
	outgoing edges:9, 
	Instructions:
		%cl_1_35 = copy(%cl_1_59)		--org.jruby.ir.instructions.CopyInstr(	%cl_1_59[6.21 ] ) 
PRINT info for BB 9:
	Vars Live on Entry: 
	Vars Live on Exit:  0 19 33		
	outgoing edges:10, 12, 
	Instructions:
		line_num(;n: 54)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_66 = call_1o(%self, key ;n:value_for, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[2.0 ] key[] ) 
		return(%cl_1_66)		--org.jruby.ir.instructions.ReturnInstr(	%cl_1_66[9.1 ] ) 
PRINT info for BB 10:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:12, 
	Instructions:
		%cl_1_67 = recv_jruby_exc()		--org.jruby.ir.instructions.ReceiveJRubyExceptionInstr(	) 
		%cl_1_68 = runtime_helper(%cl_1_67 ;method: HANDLE_BREAK_AND_RETURNS_IN_LAMBDA)		--org.jruby.ir.instructions.RuntimeHelperCall(	%cl_1_67[10.0 ] ) 
		return(%cl_1_68)		--org.jruby.ir.instructions.ReturnInstr(	%cl_1_68[10.1 ] ) 
PRINT info for BB 12:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:
CLOSURE END
		return(%v_4)		--org.jruby.ir.instructions.ReturnInstr(	%v_4[5.2 ] ) 
PRINT info for BB 6:
	Vars Live on Entry:  4 5		
	Vars Live on Exit:  4 5		
	outgoing edges:8, 
	Instructions:
		%v_5 = recv_jruby_exc()		--org.jruby.ir.instructions.ReceiveJRubyExceptionInstr(	) 
		%v_6 = runtime_helper(%v_5 ;method: HANDLE_NONLOCAL_RETURN)		--org.jruby.ir.instructions.RuntimeHelperCall(	%v_5[6.0 ] ) 
		return(%v_6)		--org.jruby.ir.instructions.ReturnInstr(	%v_6[6.1 ] ) 
PRINT info for BB 8:
	Vars Live on Entry:  4 5		
	Vars Live on Exit:  4 5		
	outgoing edges:
	Instructions:

SET IRMethod, name = find_or_create_key_for_update
PRINT info for BB 1:
	Vars Live on Entry:  4 5		
	Vars Live on Exit:  4 5		
	outgoing edges:8, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit:  4 5		
	outgoing edges:4, 5, 6, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 1, opt: 1, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		key = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		init = recv_opt_arg(;index:0, req: 1, pre: 1)		--org.jruby.ir.instructions.ReceiveOptArgInstr(	) 
		bne(LBL_0:12, init, %undefined)		--org.jruby.ir.instructions.BNEInstr(	init[2.6 ] ) 
PRINT info for BB 4:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit:  0 4		
	outgoing edges:5, 
	Instructions:
		init = copy(nil)		--org.jruby.ir.instructions.CopyInstr(	) 
PRINT info for BB 5:
	Vars Live on Entry:  4 5		
	Vars Live on Exit:  0 4 5		
	outgoing edges:6, 8, 
	Instructions:
		line_num(;n: 60)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = call(%self, %self:CLOSURE find_or_create_key_for_update_CLOSURE_1[./lobsters/models/keystore.rb:60] ;n:loop, t:FU, cl:true(org.jruby.ir.operands.WrappedIRClosure))		--org.jruby.ir.instructions.CallInstr(	%self[2.0 ] %self[2.0 ] ) 
CLOSURE BEGIN: %self[2.0,] key[2.5,] kv[] 
PRINT info for BB 1:
	Vars Live on Entry:  6 9		
	Vars Live on Exit:  6 9		
	outgoing edges:20, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry:  0 6 9		
	Vars Live on Exit:  6 9		
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%cl_1_0 = load_frame_closure()		--org.jruby.ir.instructions.LoadFrameClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
PRINT info for BB 3:
	Vars Live on Entry:  0 6 9		
	Vars Live on Exit:  0 6 9		
	outgoing edges:4, 5, 18, 
	Instructions:
		line_num(;n: 61)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_3 = call_1o(%self, true ;n:lock, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[2.0 ] ) 
		%cl_1_4 = copy({:'key'=>key})		--org.jruby.ir.instructions.CopyInstr(	key[] ) 
		%cl_1_5 = call_1o(%cl_1_3, %cl_1_4 ;n:where, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%cl_1_3[3.1 ] %cl_1_4[3.2 ] ) 
		%cl_1_6 = call_0o(%cl_1_5 ;n:first, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%cl_1_5[3.3 ] ) 
		kv = copy(%cl_1_6)		--org.jruby.ir.instructions.CopyInstr(	%cl_1_6[3.4 ] ) 
		line_num(;n: 62)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		b_false(CL1_LBL_0:17, %cl_1_6)		--org.jruby.ir.instructions.BFalseInstr(	%cl_1_6[3.4 ] ) 
PRINT info for BB 4:
	Vars Live on Entry:  6 9		
	Vars Live on Exit:  6 9		
	outgoing edges:18, 20, 
	Instructions:
		check_for_lje(;maybe_lambda: false)		--org.jruby.ir.instructions.CheckForLJEInstr(	) 
		nonlocal_return(kv ;name: find_or_create_key_for_update)		--org.jruby.ir.instructions.NonlocalReturnInstr(	kv[3.5 ] ) 
PRINT info for BB 5:
	Vars Live on Entry:  0 6 9 11		
	Vars Live on Exit:  0 6 9		
	outgoing edges:7, 
	Instructions:
		%cl_1_7 = copy(nil)		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 64)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_8 = get_global_var($!)		--org.jruby.ir.instructions.GetGlobalVariableInstr(	) 
PRINT info for BB 7:
	Vars Live on Entry:  6 9 11 13		
	Vars Live on Exit:  0 6 9 11		
	outgoing edges:9, 10, 
	Instructions:
		toggle_backtrace(;false)		--org.jruby.ir.instructions.ToggleBacktraceInstr(	) 
		line_num(;n: 65)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_11 = call(%self, %self:CLOSURE find_or_create_key_for_update_CLOSURE_1_CLOSURE_2[./lobsters/models/keystore.rb:65] ;n:create!, t:NO, cl:true(org.jruby.ir.operands.WrappedIRClosure))		--org.jruby.ir.instructions.CallInstr(	%self[2.0 ] %self[2.0 ] ) 
CLOSURE BEGIN: kv[3.5,] key[] init[] 
PRINT info for BB 1:
	Vars Live on Entry:  5 6		
	Vars Live on Exit:  5 6		
	outgoing edges:6, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry:  2 5 6		
	Vars Live on Exit:  5 6		
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%cl_2_0 = load_frame_closure()		--org.jruby.ir.instructions.LoadFrameClosureInstr(	) 
		kv = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
PRINT info for BB 3:
	Vars Live on Entry: 
	Vars Live on Exit:  2 5 6		
	outgoing edges:4, 6, 
	Instructions:
		line_num(;n: 66)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		attr_assign(kv, key ;n:key=, t:UN, cl:false)		--org.jruby.ir.instructions.specialized.OneArgOperandAttrAssignInstr(	kv[2.2 ] key[] ) #<kv>#	-- [PUT:kv].key 
		line_num(;n: 67)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		attr_assign(kv, init ;n:value=, t:UN, cl:false)		--org.jruby.ir.instructions.specialized.OneArgOperandAttrAssignInstr(	kv[3.1 2.2 ] init[] ) #<kv>#	-- [PUT:kv].value 
		line_num(;n: 68)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_2_3 = call_0o(kv ;n:save!, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	kv[3.1 3.3 2.2 ] ) 
		return(%cl_2_3)		--org.jruby.ir.instructions.ReturnInstr(	%cl_2_3[3.5 ] ) 
PRINT info for BB 4:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:6, 
	Instructions:
		%cl_2_4 = recv_jruby_exc()		--org.jruby.ir.instructions.ReceiveJRubyExceptionInstr(	) 
		%cl_2_5 = runtime_helper(%cl_2_4 ;method: HANDLE_BREAK_AND_RETURNS_IN_LAMBDA)		--org.jruby.ir.instructions.RuntimeHelperCall(	%cl_2_4[4.0 ] ) 
		return(%cl_2_5)		--org.jruby.ir.instructions.ReturnInstr(	%cl_2_5[4.1 ] ) 
PRINT info for BB 6:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:
CLOSURE END
		%cl_1_10 = copy(%cl_1_11)		--org.jruby.ir.instructions.CopyInstr(	%cl_1_11[7.2 ] ) 
		toggle_backtrace(;true)		--org.jruby.ir.instructions.ToggleBacktraceInstr(	) 
		put_global_var($!, %cl_1_8)		--org.jruby.ir.instructions.PutGlobalVarInstr(	%cl_1_8[5.2 ] ) 
PRINT info for BB 9:
	Vars Live on Entry:  6 9 13		
	Vars Live on Exit:  6 9 13		
	outgoing edges:17, 
	Instructions:
		jump(CL1_LBL_4:63)		--org.jruby.ir.instructions.JumpInstr(	) 
PRINT info for BB 10:
	Vars Live on Entry:  6 9 11 14 15 16		
	Vars Live on Exit:  6 9 11		
	outgoing edges:11, 12, 16, 
	Instructions:
		toggle_backtrace(;true)		--org.jruby.ir.instructions.ToggleBacktraceInstr(	) 
		%cl_1_12 = recv_ruby_exc()		--org.jruby.ir.instructions.ReceiveRubyExceptionInstr(	) 
		%cl_1_13 = search_const(scope<2> ;name: ActiveRecord, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%cl_1_14 = inheritance_search_const(%cl_1_13 ;name: RecordNotUnique, no_priv: true)		--org.jruby.ir.instructions.InheritanceSearchConstInstr(	%cl_1_13[10.2 ] ) 
		bne(CL1_LBL_11:44, %cl_1_14, %undefined)		--org.jruby.ir.instructions.BNEInstr(	%cl_1_14[10.3 ] ) 
PRINT info for BB 11:
	Vars Live on Entry:  6 9 11 14 16		
	Vars Live on Exit:  6 9 11 14 15		
	outgoing edges:12, 16, 
	Instructions:
		%cl_1_14 = const_missing(%cl_1_13, :'RecordNotUnique' ;n:const_missing, t:FU, cl:false, missing: RecordNotUnique)		--org.jruby.ir.instructions.ConstMissingInstr(	%cl_1_13[10.2 ] ) 
PRINT info for BB 12:
	Vars Live on Entry:  6 9 11 14		
	Vars Live on Exit:  6 9 11 14 16		
	outgoing edges:13, 14, 16, 
	Instructions:
		%cl_1_15 = rescue_eqq(Array:[%cl_1_14], %cl_1_12)		--org.jruby.ir.instructions.RescueEQQInstr(	%cl_1_14[11.0 10.3 ] %cl_1_12[10.1 ] ) 
		b_true(CL1_LBL_10:49, %cl_1_15)		--org.jruby.ir.instructions.BTrueInstr(	%cl_1_15[12.0 ] ) 
PRINT info for BB 13:
	Vars Live on Entry:  6 9 11		
	Vars Live on Exit:  6 9 11 14		
	outgoing edges:16, 20, 
	Instructions:
		throw(%cl_1_12)		--org.jruby.ir.instructions.ThrowExceptionInstr(	%cl_1_12[10.1 ] ) 
PRINT info for BB 14:
	Vars Live on Entry:  6 9 11 13		
	Vars Live on Exit:  6 9 11		
	outgoing edges:15, 16, 
	Instructions:
		line_num(;n: 72)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%cl_1_10 = copy(nil)		--org.jruby.ir.instructions.CopyInstr(	) 
		toggle_backtrace(;true)		--org.jruby.ir.instructions.ToggleBacktraceInstr(	) 
		put_global_var($!, %cl_1_8)		--org.jruby.ir.instructions.PutGlobalVarInstr(	%cl_1_8[5.2 ] ) 
PRINT info for BB 15:
	Vars Live on Entry:  6 9 13		
	Vars Live on Exit:  6 9 13		
	outgoing edges:17, 
	Instructions:
		jump(CL1_LBL_4:63)		--org.jruby.ir.instructions.JumpInstr(	) 
PRINT info for BB 16:
	Vars Live on Entry:  6 9		
	Vars Live on Exit:  6 9 11		
	outgoing edges:18, 20, 
	Instructions:
		%cl_1_16 = recv_jruby_exc()		--org.jruby.ir.instructions.ReceiveJRubyExceptionInstr(	) 
		%cl_1_17 = runtime_helper(%cl_1_16, %cl_1_8 ;method: RESTORE_EXCEPTION_VAR)		--org.jruby.ir.instructions.RuntimeHelperCall(	%cl_1_16[16.0 ] %cl_1_8[5.2 ] ) 
		throw(%cl_1_16)		--org.jruby.ir.instructions.ThrowExceptionInstr(	%cl_1_16[16.0 ] ) 
PRINT info for BB 17:
	Vars Live on Entry:  6 9		
	Vars Live on Exit:  6 9 13		
	outgoing edges:20, 
	Instructions:
		return(%cl_1_10)		--org.jruby.ir.instructions.ReturnInstr(	%cl_1_10[7.3 14.1 ] ) 
PRINT info for BB 18:
	Vars Live on Entry:  6 9		
	Vars Live on Exit:  6 9		
	outgoing edges:20, 
	Instructions:
		%cl_1_18 = recv_jruby_exc()		--org.jruby.ir.instructions.ReceiveJRubyExceptionInstr(	) 
		%cl_1_19 = runtime_helper(%cl_1_18 ;method: HANDLE_BREAK_AND_RETURNS_IN_LAMBDA)		--org.jruby.ir.instructions.RuntimeHelperCall(	%cl_1_18[18.0 ] ) 
		return(%cl_1_19)		--org.jruby.ir.instructions.ReturnInstr(	%cl_1_19[18.1 ] ) 
PRINT info for BB 20:
	Vars Live on Entry:  6 9		
	Vars Live on Exit:  6 9		
	outgoing edges:
	Instructions:
CLOSURE END
		return(%v_3)		--org.jruby.ir.instructions.ReturnInstr(	%v_3[5.1 ] ) 
PRINT info for BB 6:
	Vars Live on Entry:  4 5		
	Vars Live on Exit:  4 5		
	outgoing edges:8, 
	Instructions:
		%v_4 = recv_jruby_exc()		--org.jruby.ir.instructions.ReceiveJRubyExceptionInstr(	) 
		%v_5 = runtime_helper(%v_4 ;method: HANDLE_NONLOCAL_RETURN)		--org.jruby.ir.instructions.RuntimeHelperCall(	%v_4[6.0 ] ) 
		return(%v_5)		--org.jruby.ir.instructions.ReturnInstr(	%v_5[6.1 ] ) 
PRINT info for BB 8:
	Vars Live on Entry:  4 5		
	Vars Live on Exit:  4 5		
	outgoing edges:
	Instructions:

SET IRMethod, name = decrement_value_for
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:5, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit: 
	outgoing edges:3, 4, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 1, opt: 1, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		key = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		amount = recv_opt_arg(;index:0, req: 1, pre: 1)		--org.jruby.ir.instructions.ReceiveOptArgInstr(	) 
		bne(LBL_0:10, amount, %undefined)		--org.jruby.ir.instructions.BNEInstr(	amount[2.6 ] ) 
PRINT info for BB 3:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit:  0 4		
	outgoing edges:4, 
	Instructions:
		amount = copy(Fixnum:-1)		--org.jruby.ir.instructions.CopyInstr(	) 
PRINT info for BB 4:
	Vars Live on Entry: 
	Vars Live on Exit:  0 4 5		
	outgoing edges:5, 
	Instructions:
		line_num(;n: 77)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = call(%self, key, amount ;n:increment_value_for, t:NO, cl:false)		--org.jruby.ir.instructions.CallInstr(	%self[2.0 ] key[2.5 ] amount[3.0 2.6 ] ) 
		return(%v_3)		--org.jruby.ir.instructions.ReturnInstr(	%v_3[4.1 ] ) 
PRINT info for BB 5:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = decremented_value_for
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:5, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit: 
	outgoing edges:3, 4, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 1, opt: 1, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		key = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		amount = recv_opt_arg(;index:0, req: 1, pre: 1)		--org.jruby.ir.instructions.ReceiveOptArgInstr(	) 
		bne(LBL_0:10, amount, %undefined)		--org.jruby.ir.instructions.BNEInstr(	amount[2.6 ] ) 
PRINT info for BB 3:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit:  0 4		
	outgoing edges:4, 
	Instructions:
		amount = copy(Fixnum:-1)		--org.jruby.ir.instructions.CopyInstr(	) 
PRINT info for BB 4:
	Vars Live on Entry: 
	Vars Live on Exit:  0 4 5		
	outgoing edges:5, 
	Instructions:
		line_num(;n: 81)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = call(%self, key, amount ;n:incremented_value_for, t:NO, cl:false)		--org.jruby.ir.instructions.CallInstr(	%self[2.0 ] key[2.5 ] amount[3.0 2.6 ] ) 
		return(%v_3)		--org.jruby.ir.instructions.ReturnInstr(	%v_3[4.1 ] ) 
PRINT info for BB 5:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

