SET IRMethod, name = initialize
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 1, opt: 0, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		klass = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		line_num(;n: 4)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		attr_assign(%self, klass ;n:klass=, t:UN, cl:false)		--org.jruby.ir.instructions.specialized.OneArgOperandAttrAssignInstr(	%self[2.0 ] klass[2.5 ] ) #<%self>#	-- [PUT:%self].klass 
		line_num(;n: 5)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		attr_assign(%self, Fixnum:0 ;n:generation_attempts=, t:UN, cl:false)		--org.jruby.ir.instructions.specialized.OneArgOperandAttrAssignInstr(	%self[2.0 2.7 ] ) #<%self>#	-- [PUT:%self].generation_attempts 
		return(Fixnum:0)		--org.jruby.ir.instructions.ReturnInstr(	) 
PRINT info for BB 3:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = generate
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:13, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry:  0		
	Vars Live on Exit: 
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 0, opt: 0, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		line_num(;n: 9)		--org.jruby.ir.instructions.LineNumberInstr(	) 
PRINT info for BB 3:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit:  0		
	outgoing edges:4, 5, 
	Instructions:
		%v_4 = call_0o(%self ;n:candidate_id, t:VA, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%self[2.0 6.4 ] ) 
		generated_id = copy(%v_4)		--org.jruby.ir.instructions.CopyInstr(	%v_4[3.0 ] ) 
		b_false(LBL_1:13, %v_4)		--org.jruby.ir.instructions.BFalseInstr(	%v_4[3.0 ] ) 
PRINT info for BB 4:
	Vars Live on Entry:  0 4 5		
	Vars Live on Exit:  0 5		
	outgoing edges:5, 
	Instructions:
		%v_5 = call_0o(generated_id ;n:valid?, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	generated_id[3.1 ] ) 
		%v_4 = copy(%v_5)		--org.jruby.ir.instructions.CopyInstr(	%v_5[4.0 ] ) 
PRINT info for BB 5:
	Vars Live on Entry:  0 5		
	Vars Live on Exit:  0 4 5		
	outgoing edges:6, 11, 
	Instructions:
		b_true(LBL_0:33, %v_4)		--org.jruby.ir.instructions.BTrueInstr(	%v_4[4.1 3.0 ] ) 
PRINT info for BB 6:
	Vars Live on Entry:  0		
	Vars Live on Exit:  0		
	outgoing edges:7, 8, 
	Instructions:
		thread_poll()		--org.jruby.ir.instructions.ThreadPollInstr(	) 
		line_num(;n: 10)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_6 = call_0o(%self ;n:generation_attempts, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%self[2.0 ] ) 
		%v_8 = call_1f(%v_6, Fixnum:1 ;n:+, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneFixnumArgNoBlockCallInstr(	%v_6[6.2 ] ) 
		%v_7 = call_1o(%self, %v_8 ;n:generation_attempts=, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[6.2 2.0 ] %v_8[6.3 ] ) #<%self>#	-- [PUT:%self].generation_attempts 
		line_num(;n: 11)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_9 = call_0o(%self ;n:generation_attempts, t:VA, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%self[6.2 6.4 2.0 ] ) 
		%v_10 = call_1f(%v_9, Fixnum:10 ;n:==, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneFixnumArgNoBlockCallInstr(	%v_9[6.6 ] ) 
		b_false(LBL_2:28, %v_10)		--org.jruby.ir.instructions.BFalseInstr(	%v_10[6.7 ] ) 
PRINT info for BB 7:
	Vars Live on Entry:  0		
	Vars Live on Exit:  0		
	outgoing edges:9, 
	Instructions:
		%v_11 = copy("too many hash collisions")		--org.jruby.ir.instructions.CopyInstr(	) 
		%v_12 = call_1o(%self, %v_11 ;n:raise, t:FU, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%self[6.4 2.0 ] %v_11[7.0 ] ) 
		jump(LBL_3:30)		--org.jruby.ir.instructions.JumpInstr(	) 
PRINT info for BB 8:
	Vars Live on Entry:  0		
	Vars Live on Exit:  0		
	outgoing edges:9, 
	Instructions:
		%v_12 = copy(nil)		--org.jruby.ir.instructions.CopyInstr(	) 
PRINT info for BB 9:
	Vars Live on Entry:  0		
	Vars Live on Exit:  0		
	outgoing edges:3, 
	Instructions:
		jump(_LOOP_BEGIN_0:7)		--org.jruby.ir.instructions.JumpInstr(	) 
PRINT info for BB 11:
	Vars Live on Entry: 
	Vars Live on Exit:  5		
	outgoing edges:13, 
	Instructions:
		%v_3 = copy(nil)		--org.jruby.ir.instructions.CopyInstr(	) 
		line_num(;n: 13)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_13 = call_0o(generated_id ;n:to_s, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	generated_id[3.1 ] ) 
		return(%v_13)		--org.jruby.ir.instructions.ReturnInstr(	%v_13[11.2 ] ) 
PRINT info for BB 13:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = candidate_id
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 0, opt: 0, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		line_num(;n: 17)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = search_const(scope<1> ;name: CandidateId, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%v_4 = call_0o(%self ;n:klass, t:VA, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%self[2.0 ] ) 
		%v_5 = call_1o(%v_3, %v_4 ;n:new, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%v_3[2.6 ] %v_4[2.7 ] ) 
		return(%v_5)		--org.jruby.ir.instructions.ReturnInstr(	%v_5[2.8 ] ) 
PRINT info for BB 3:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = initialize
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 1, opt: 0, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		klass = recv_pre_reqd_arg()		--org.jruby.ir.instructions.ReceivePreReqdArgInstr(	) 
		line_num(;n: 25)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		attr_assign(%self, klass ;n:klass=, t:UN, cl:false)		--org.jruby.ir.instructions.specialized.OneArgOperandAttrAssignInstr(	%self[2.0 ] klass[2.5 ] ) #<%self>#	-- [PUT:%self].klass 
		line_num(;n: 26)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = call_0o(%self ;n:generate_id, t:VA, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%self[2.0 2.7 ] ) 
		attr_assign(%self, %v_3 ;n:id=, t:UN, cl:false)		--org.jruby.ir.instructions.specialized.OneArgOperandAttrAssignInstr(	%self[2.0 2.7 2.9 ] %v_3[2.9 ] ) #<%self>#	-- [PUT:%self].id 
		return(%v_3)		--org.jruby.ir.instructions.ReturnInstr(	%v_3[2.9 ] ) 
PRINT info for BB 3:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = to_s
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 0, opt: 0, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		line_num(;n: 30)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = call_0o(%self ;n:id, t:VA, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%self[2.0 ] ) 
		return(%v_3)		--org.jruby.ir.instructions.ReturnInstr(	%v_3[2.6 ] ) 
PRINT info for BB 3:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = generate_id
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 
	Instructions:
		%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 0, opt: 0, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		line_num(;n: 34)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = search_const(scope<1> ;name: Utils, no_priv: false)		--org.jruby.ir.instructions.SearchConstInstr(	) 
		%v_4 = call_1f(%v_3, Fixnum:6 ;n:random_str, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneFixnumArgNoBlockCallInstr(	%v_3[2.6 ] ) 
		%v_5 = call_0o(%v_4 ;n:downcase, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_4[2.7 ] ) 
		return(%v_5)		--org.jruby.ir.instructions.ReturnInstr(	%v_5[2.8 ] ) 
PRINT info for BB 3:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

SET IRMethod, name = valid?
PRINT info for BB 1:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 2, 
	Instructions:
PRINT info for BB 2:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:3, 
	Instructions:
		[DEAD]%self = recv_self()		--org.jruby.ir.instructions.ReceiveSelfInstr(	) 
		%v_0 = load_implicit_closure()		--org.jruby.ir.instructions.LoadImplicitClosureInstr(	) 
		%current_scope = copy(scope<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		%current_module = copy(module<0>)		--org.jruby.ir.instructions.CopyInstr(	) 
		check_arity(;req: 0, opt: 0, *r: false, kw: false)		--org.jruby.ir.instructions.CheckArityInstr(	) 
		line_num(;n: 38)		--org.jruby.ir.instructions.LineNumberInstr(	) 
		%v_3 = call_0o(%self ;n:klass, t:VA, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%self[2.0 ] ) 
		%v_4 = call_0o(%self ;n:id, t:VA, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%self[2.0 2.6 ] ) 
		%v_5 = copy({:'short_id'=>%v_4})		--org.jruby.ir.instructions.CopyInstr(	%v_4[2.7 ] ) 
		%v_6 = call_1o(%v_3, %v_5 ;n:exists?, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.OneOperandArgNoBlockCallInstr(	%v_3[2.6 ] %v_5[2.8 ] ) 
		%v_7 = call_0o(%v_6 ;n:!, t:NO, cl:false)		--org.jruby.ir.instructions.specialized.ZeroOperandArgNoBlockCallInstr(	%v_6[2.9 ] ) 
		return(%v_7)		--org.jruby.ir.instructions.ReturnInstr(	%v_7[2.10 ] ) 
PRINT info for BB 3:
	Vars Live on Entry: 
	Vars Live on Exit: 
	outgoing edges:
	Instructions:

