level 0: CommentsController . before_filter (params: ) # (returnv: )
	level 1: ApplicationController . before_filter (params: ) # (returnv: )
		level 2: ApplicationController . authenticate_user (params: ) # (returnv: )
			level 3:  [QUERY] User . where	{params: session[:u], } # {returnv: true} # {op: User.SELECT}
			level 3:  [QUERY] User.where(:session_token => session[:u].to_s) . first	{params: } # {returnv: user} # {op: .SELECT}
			level 3: User . before_filter (params: ) # (returnv: )
			level 3: User . is_active? (params: ) # (returnv: true)
				level 4: User . is_banned? (params: ) # (returnv: )
			level 1: ApplicationController . increase_traffic_counter (params: ) # (returnv: )
		level 2: ApplicationController . user_is_spider? (params: ) # (returnv: true)
		level 2: Keystore . before_filter (params: ) # (returnv: )
		level 2: Keystore . find_or_create_key_for_update (params: now_i, ) # (returnv: date_kv)
			level 3:  [QUERY] self.lock(true).where(:key => key) . first	{params: } # {returnv: kv} # {op: .SELECT}
			level 3:  [QUERY] self.lock(true) . where	{params: key, } # {returnv: } # {op: .SELECT}
			level 3:  [QUERY] self . lock	{params: true, } # {returnv: } # {op: Keystore.TRANSACTION}
=====transaction begin=====
			level 3:  [QUERY] kv . save!	{params: } # {returnv: } # {op: Keystore.INSERT}
				level 4: Keystore . before_save (params: ) # (returnv: )
				level 4: Keystore . before_validation (params: ) # (returnv: )
					level 5:  [QUERY] key . where	{params: } # {returnv: } # {op: .SELECT}
				level 4: Keystore . before_create (params: ) # (returnv: )
=====transaction end=====
=====transaction begin=====
		level 2:  [QUERY] traffic_kv . save!	{params: } # {returnv: } # {op: Keystore.INSERT}
=====transaction end=====
=====transaction begin=====
		level 2:  [QUERY] date_kv . save!	{params: } # {returnv: } # {op: Keystore.INSERT}
=====transaction end=====
	level 1: ApplicationController . find_user_from_rss_token (params: ) # (returnv: )
		level 2:  [QUERY] User . where	{params: params[:token], } # {returnv: } # {op: User.SELECT}
		level 2:  [QUERY] User.where(:rss_token => params[:token].to_s) . first	{params: } # {returnv: @user} # {op: .SELECT}
	level 1: ApplicationController . require_logged_in_user_or_400 (params: ) # (returnv: )
	level 0: CommentsController . update (params: ) # (returnv: )
	level 1: CommentsController . find_comment (params: ) # (returnv: comment)
		level 2:  [QUERY] Comment . where	{params: params[:id], } # {returnv: } # {op: Comment.SELECT}
		level 2:  [QUERY] Comment.where(:short_id => params[:id]) . first	{params: } # {returnv: comment} # {op: .SELECT}
		level 2:  [QUERY] Vote . where	{params: @user, comment, comment, } # {returnv: } # {op: Vote.SELECT}
		level 2:  [QUERY] Vote.where(:user_id => @user.id,        :story_id => comment.story_id, :comment_id => comment.id) . first	{params: } # {returnv: comment.current_vote} # {op: .SELECT}
	level 1: Comment . before_filter (params: ) # (returnv: )
	level 1: Comment . is_editable_by_user? (params: @user, ) # (returnv: true)
	level 1:  [QUERY] @user.hats . where	{params: params[:hat_id], } # {returnv: true} # {op: Hat.SELECT}
=====transaction begin=====
	level 1:  [QUERY] comment . save	{params: } # {returnv: true} # {op: Comment.INSERT}
		level 2: Comment . before_save (params: ) # (returnv: )
		level 2: Comment . before_validation (params: ) # (returnv: )
			level 3: Comment . before_validation_do_block (params: ) # (returnv: )
				level 4: Comment . assign_short_id_and_upvote (params: ) # (returnv: )
					level 5: ShortId . before_filter (params: ) # (returnv: )
					level 5: ShortId . generate (params: ) # (returnv: self.short_id)
						level 6: ShortId . candidate_id (params: ) # (returnv: generated_id)
				level 4: Comment . assign_initial_confidence (params: ) # (returnv: )
					level 5: Comment . calculated_confidence (params: ) # (returnv: self.confidence)
				level 4: Comment . assign_thread_id (params: ) # (returnv: )
					level 5: Keystore . incremented_value_for (params: ) # (returnv: self.thread_id)
						======transaction begin=====
=====transaction begin=====
						level 6:  [QUERY] Keystore.connection . execute	{params: Keystore, } # {returnv: } # {op: .INSERT}
=====transaction end=====
=====transaction begin=====
						level 6:  [QUERY] Keystore.connection . execute	{params: Keystore, } # {returnv: } # {op: .UPDATE}
=====transaction end=====
=====transaction begin=====
						level 6:  [QUERY] Keystore.connection . execute	{params: Keystore, } # {returnv: } # {op: .UPDATE}
=====transaction end=====
=====transaction begin=====
						level 6:  [QUERY] kv . save!	{params: } # {returnv: } # {op: .INSERT}
=====transaction end=====
						level 6: Keystore . value_for (params: key, ) # (returnv: )
							level 7:  [QUERY] self.where(:key => key).first . try	{params: } # {returnv: } # {op: .SELECT}
							level 7:  [QUERY] self.where(:key => key) . first	{params: } # {returnv: } # {op: .SELECT}
							level 7:  [QUERY] self . where	{params: key, } # {returnv: } # {op: Keystore.SELECT}
						======transaction end=====
		level 2: Comment . before_create (params: ) # (returnv: )
			level 3: Comment . record_initial_upvote (params: ) # (returnv: )
				level 4: Vote . before_filter (params: ) # (returnv: )
				level 4: Vote . vote_thusly_on_story_or_comment_for_user_because (params: self, self, self, nil, false, ) # (returnv: )
					level 5:  [QUERY] Vote . where	{params: user_id, story_id, comment_id, } # {returnv: } # {op: Vote.SELECT}
					level 5:  [QUERY] Vote.where(:user_id => user_id, :story_id => story_id,      :comment_id => comment_id) . first_or_initialize	{params: } # {returnv: v} # {op: .SELECT}
					level 5:  [QUERY] v . destroy!	{params: } # {returnv: } # {op: Vote.DELETE}
=====transaction begin=====
					level 5:  [QUERY] v . new_record?	{params: } # {returnv: true} # {op: Vote.INSERT}
						level 6: Vote . before_save (params: ) # (returnv: )
						level 6: Vote . before_validation (params: ) # (returnv: )
						level 6: Vote . before_create (params: ) # (returnv: )
=====transaction end=====
=====transaction begin=====
					level 5:  [QUERY] v . save!	{params: } # {returnv: } # {op: Vote.INSERT}
=====transaction end=====
					level 5:  [QUERY] Comment . find	{params: v, } # {returnv: c} # {op: Comment.SELECT}
=====transaction begin=====
					level 5:  [QUERY] User . update_counters	{params: } # {returnv: } # {op: User.UPDATE}
						level 6: User . before_save (params: ) # (returnv: )
							level 7: User . check_session_token (params: ) # (returnv: )
						level 6: User . before_validation (params: ) # (returnv: )
							level 7: User . before_validation_do_block (params: ) # (returnv: )
								level 8: User . create_rss_token (params: ) # (returnv: )
								level 8: User . create_mailing_list_token (params: ) # (returnv: )
=====transaction end=====
					level 5: Comment . give_upvote_or_downvote_and_recalculate_confidence! (params: upvote, downvote, ) # (returnv: )
=====transaction begin=====
						level 6:  [QUERY] Comment.connection . execute	{params: Comment, } # {returnv: } # {op: .UPDATE}
=====transaction end=====
						level 6: Story . before_filter (params: ) # (returnv: )
						level 6: Story . recalculate_hotness! (params: ) # (returnv: )
							level 7: Story . calculated_hotness (params: ) # (returnv: )
								level 8:  [QUERY] self.tags . select	{params: } # {returnv: } # {op: Tag.SELECT}
								level 8:  [QUERY] self.comments . where	{params: self, } # {returnv: } # {op: Comment.SELECT}
								level 8:  [QUERY] self.comments.where("user_id <> ?", self.user_id) . select	{params: } # {returnv: } # {op: .SELECT}
								level 8: Story . score (params: ) # (returnv: )
					level 5:  [QUERY] Story . find	{params: v, } # {returnv: s} # {op: Story.SELECT}
=====transaction begin=====
					level 5:  [QUERY] User . update_counters	{params: } # {returnv: } # {op: User.UPDATE}
=====transaction end=====
					level 5: Story . give_upvote_or_downvote_and_recalculate_hotness! (params: upvote, downvote, ) # (returnv: )
=====transaction begin=====
						level 6:  [QUERY] Story.connection . execute	{params: Story, } # {returnv: } # {op: .UPDATE}
=====transaction end=====
				level 4: Story . update_comments_count! (params: ) # (returnv: )
					level 5: Story . merged_comments (params: ) # (returnv: )
						level 6:  [QUERY] Story . select	{params: } # {returnv: } # {op: Story.SELECT}
						level 6:  [QUERY] Story.select(:id) . where	{params: self, } # {returnv: } # {op: .SELECT}
						level 6:  [QUERY] Comment . where	{params: Story, } # {returnv: } # {op: Comment.SELECT}
					level 5: Comment . arrange_for_user (params: nil, ) # (returnv: comments)
						level 6:  [QUERY] self . order	{params: } # {returnv: } # {op: Comment.SELECT}
						level 6: Comment . is_gone? (params: ) # (returnv: true)
					level 5:  [QUERY] comments . count	{params: } # {returnv: self.comments_count} # {op: Comment.SELECT}
			level 3: Comment . mark_submitter (params: ) # (returnv: )
				level 4: Keystore . increment_value_for (params: self, ) # (returnv: )
			level 3: Comment . deliver_reply_notifications (params: ) # (returnv: )
				level 4:  [QUERY] self.parent_comment . try	{params: } # {returnv: u} # {op: .SELECT}
				level 4: Comment . plaintext_comment (params: ) # (returnv: )
				level 4: Comment . url (params: ) # (returnv: )
					level 5: Story . comments_url (params: ) # (returnv: )
						level 6: Story . short_id_url (params: ) # (returnv: )
						level 6: Story . title_as_url (params: ) # (returnv: )
				level 4: User . pushover! (params: Rails, ) # (returnv: )
			level 3: Comment . deliver_mention_notifications (params: ) # (returnv: )
				level 4:  [QUERY] self.plaintext_comment.scan(/\B\@([\w\-]+)/).flatten . uniq	{params: } # {returnv: } # {op: .SELECT}
				level 4:  [QUERY] User . where	{params: mention, } # {returnv: true} # {op: User.SELECT}
				level 4:  [QUERY] User.where(:username => mention) . first	{params: } # {returnv: u} # {op: .SELECT}
			level 3: Comment . log_to_countinual (params: ) # (returnv: )
=====transaction end=====
	level 1: Vote . comment_votes_by_user_for_comment_ids_hash (params: @user, comment, ) # (returnv: votes)
		level 2:  [QUERY] self . where	{params: user_id, comment_ids, } # {returnv: votes} # {op: Vote.SELECT}
	level 1: Comment . score (params: ) # (returnv: )
	level 1: User . can_downvote? (params: comment, ) # (returnv: true)
		level 2: User . is_new? (params: ) # (returnv: true)
		level 2:  [QUERY] obj.current_vote . try	{params: } # {returnv: true} # {op: .SELECT}
	level 1: User . avatar_url (params: ) # (returnv: )
	level 1: Hat . before_filter (params: ) # (returnv: )
	level 1: Hat . to_html_label (params: ) # (returnv: )
	level 1: Comment . has_been_edited? (params: ) # (returnv: true)
	level 1: Comment . is_undeletable_by_user? (params: @user, ) # (returnv: true)
	level 1: Comment . is_deletable_by_user? (params: @user, ) # (returnv: true)
	level 1: Comment . vote_summary (params: ) # (returnv: )
		level 2:  [QUERY] Vote . where	{params: self, } # {returnv: } # {op: Vote.SELECT}
		level 2:  [QUERY] r_counts.keys.sort.map{|k|      k == "" ? "+#{r_counts[k]}" : "#{r_counts[k]} #{Vote::COMMENT_REASONS[k]}"    } . join	{params: } # {returnv: } # {op: .JOIN}
	level 1: Story . comments_path (params: ) # (returnv: )
		level 2: Story . short_id_path (params: ) # (returnv: )
	level 1: Comment . gone_text (params: ) # (returnv: )
		level 2:  [QUERY] self.moderation.try(:moderator) . try	{params: } # {returnv: } # {op: .SELECT}
		level 2:  [QUERY] self.moderation.try(:moderator) . try	{params: } # {returnv: } # {op: .SELECT}
		level 2:  [QUERY] self.moderation.try(:moderator) . try	{params: } # {returnv: } # {op: .SELECT}
