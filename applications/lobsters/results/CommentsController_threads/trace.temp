level 0: CommentsController . before_filter (params: ) # (returnv: )
	level 1: ApplicationController . before_filter (params: ) # (returnv: )
		level 2: ApplicationController . authenticate_user (params: ) # (returnv: )
			level 3:  [QUERY] User . where	{params: session[:u], } # {returnv: true} # {op: User.SELECT}
			level 3:  [QUERY] User.where(:session_token => session[:u].to_s) . first	{params: } # {returnv: user} # {op: .SELECT}
			level 3: User . before_filter (params: ) # (returnv: )
			level 3: User . is_active? (params: ) # (returnv: true)
				level 4: User . is_banned? (params: ) # (returnv: )
			level 1: ApplicationController . increase_traffic_counter (params: ) # (returnv: )
		level 2: ApplicationController . user_is_spider? (params: ) # (returnv: true)
		level 2: Keystore . before_filter (params: ) # (returnv: )
		level 2: Keystore . find_or_create_key_for_update (params: now_i, ) # (returnv: date_kv)
			level 3:  [QUERY] self . lock	{params: true, } # {returnv: } # {op: .TXN}
			level 3:  [QUERY] self.lock(true) . where	{params: key, } # {returnv: } # {op: .SELECT}
			level 3:  [QUERY] self.lock(true).where(:key => key) . first	{params: } # {returnv: kv} # {op: .SELECT}
=====transaction begin=====
			level 3:  [QUERY] kv . save!	{params: } # {returnv: } # {op: .INSERT}
=====transaction end=====
		level 0: CommentsController . threads (params: ) # (returnv: )
	level 1:  [QUERY] User . where	{params: params[:user], } # {returnv: } # {op: User.SELECT}
	level 1:  [QUERY] User.where(:username => params[:user]) . first!	{params: } # {returnv: @showing_user} # {op: .SELECT}
	level 1: User . recent_threads (params: @user, ) # (returnv: thread_ids)
		level 2:  [QUERY] self.comments . group	{params: } # {returnv: } # {op: Comment.GROUP}
		level 2:  [QUERY] self.comments.group(:thread_id) . order	{params: } # {returnv: } # {op: .SELECT}
		level 2:  [QUERY] self.comments.group(:thread_id).order('MAX(created_at) DESC') . limit	{params: amount, } # {returnv: } # {op: .SELECT}
	level 1:  [QUERY] Comment . where	{params: thread_ids, } # {returnv: } # {op: Comment.SELECT}
	level 1:  [QUERY] Comment.where(      :thread_id => thread_ids    ) . includes	{params: } # {returnv: } # {op: .SELECT}
	level 1: Comment . before_filter (params: ) # (returnv: )
	level 1: Comment . arrange_for_user (params: @showing_user, ) # (returnv: comments)
		level 2:  [QUERY] self . order	{params: } # {returnv: } # {op: .SELECT}
		level 2:  [QUERY] self.order("confidence DESC") . group_by	{params: } # {returnv: parents} # {op: .SELECT}
	level 1:  [QUERY] comments.map(&:story_id) . uniq	{params: } # {returnv: } # {op: .SELECT}
	level 1: Vote . before_filter (params: ) # (returnv: )
	level 1: Vote . comment_votes_by_user_for_story_hash (params: @user, comments, ) # (returnv: @votes)
		level 2:  [QUERY] Vote.where(      :user_id => user_id, :story_id => story_id    ) . where	{params: } # {returnv: } # {op: .SELECT}
		level 2:  [QUERY] Vote.where(      :user_id => user_id, :story_id => story_id    ) . where	{params: } # {returnv: } # {op: .SELECT}
	level 1: Comment . score (params: ) # (returnv: )
	level 1: Comment . is_gone? (params: ) # (returnv: true)
	level 1: User . can_downvote? (params: comment, ) # (returnv: true)
		level 2:  [QUERY] obj.current_vote . try	{params: } # {returnv: true} # {op: .SELECT}
	level 1: User . avatar_url (params: ) # (returnv: )
	level 1: Hat . before_filter (params: ) # (returnv: )
	level 1: Hat . to_html_label (params: ) # (returnv: )
	level 1: Comment . has_been_edited? (params: ) # (returnv: true)
	level 1: Comment . url (params: ) # (returnv: )
		level 2: Story . before_filter (params: ) # (returnv: )
		level 2: Story . comments_url (params: ) # (returnv: )
			level 3: Story . title_as_url (params: ) # (returnv: )
	level 1: Comment . is_editable_by_user? (params: @user, ) # (returnv: true)
	level 1: Comment . is_undeletable_by_user? (params: @user, ) # (returnv: true)
	level 1: Comment . is_deletable_by_user? (params: @user, ) # (returnv: true)
	level 1: Story . is_gone? (params: ) # (returnv: true)
	level 1:  [QUERY] @user . try	{params: } # {returnv: true} # {op: User.SELECT}
	level 1:  [QUERY] @user . try	{params: } # {returnv: true} # {op: User.SELECT}
	level 1: Comment . vote_summary (params: ) # (returnv: )
		level 2:  [QUERY] Vote . where	{params: self, } # {returnv: } # {op: Vote.SELECT}
		level 2:  [QUERY] r_counts.keys.sort.map{|k|      k == "" ? "+#{r_counts[k]}" : "#{r_counts[k]} #{Vote::COMMENT_REASONS[k]}"    } . join	{params: } # {returnv: } # {op: .JOIN}
	level 1: Story . comments_path (params: ) # (returnv: )
	level 1: Comment . gone_text (params: ) # (returnv: )
		level 2:  [QUERY] self.moderation . try	{params: } # {returnv: } # {op: Moderation.SELECT}
		level 2:  [QUERY] self.moderation . try	{params: } # {returnv: } # {op: Moderation.SELECT}
		level 2:  [QUERY] self.moderation . try	{params: } # {returnv: } # {op: Moderation.SELECT}
