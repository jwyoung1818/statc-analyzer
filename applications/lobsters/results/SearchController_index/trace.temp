level 0: SearchController . before_filter (params: ) # (returnv: )
	level 1: ApplicationController . before_filter (params: ) # (returnv: )
		level 2: ApplicationController . authenticate_user (params: ) # (returnv: )
			level 3:  [QUERY] User . where	{params: session[:u], } # {returnv: true} # {op: User.SELECT}
			level 3:  [QUERY] User.where(:session_token => session[:u].to_s) . first	{params: } # {returnv: user} # {op: .SELECT}
			level 3: User . before_filter (params: ) # (returnv: )
			level 3: User . is_active? (params: ) # (returnv: true)
				level 4: User . is_banned? (params: ) # (returnv: )
			level 1: ApplicationController . increase_traffic_counter (params: ) # (returnv: )
		level 2: ApplicationController . user_is_spider? (params: ) # (returnv: true)
		level 2: Keystore . before_filter (params: ) # (returnv: )
		level 2: Keystore . find_or_create_key_for_update (params: now_i, ) # (returnv: date_kv)
			level 3:  [QUERY] self.lock(true).where(:key => key) . first	{params: } # {returnv: kv} # {op: .SELECT}
			level 3:  [QUERY] self.lock(true) . where	{params: key, } # {returnv: } # {op: .SELECT}
			level 3:  [QUERY] self . lock	{params: true, } # {returnv: } # {op: Keystore.TRANSACTION}
=====transaction begin=====
			level 3:  [QUERY] kv . save!	{params: } # {returnv: } # {op: Keystore.INSERT}
				level 4: Keystore . before_save (params: ) # (returnv: )
				level 4: Keystore . before_validation (params: ) # (returnv: )
					level 5:  [QUERY] key . where	{params: } # {returnv: } # {op: .SELECT}
				level 4: Keystore . before_create (params: ) # (returnv: )
=====transaction end=====
=====transaction begin=====
		level 2:  [QUERY] traffic_kv . save!	{params: } # {returnv: } # {op: Keystore.INSERT}
=====transaction end=====
=====transaction begin=====
		level 2:  [QUERY] date_kv . save!	{params: } # {returnv: } # {op: Keystore.INSERT}
=====transaction end=====
	level 0: SearchController . index (params: ) # (returnv: )
	level 1:  [QUERY] @search . order	{params: } # {returnv: } # {op: Search.SELECT}
	level 1: Search . before_filter (params: ) # (returnv: )
	level 1: Search . search_for_user! (params: @user, ) # (returnv: )
		level 2: Search . page_count (params: ) # (returnv: )
			level 3: Search . max_matches (params: ) # (returnv: true)
		level 2:  [QUERY] self . order	{params: } # {returnv: true} # {op: Search.SELECT}
		level 2:  [QUERY] self . order	{params: } # {returnv: true} # {op: Search.SELECT}
		level 2:  [QUERY] self.q.to_s.split(" ").reject{|w|      if m = w.match(/^domain:(.+)$/)        domain = m[1]      end    } . join	{params: } # {returnv: words} # {op: .JOIN}
		level 2:  [QUERY] Story . select	{params: } # {returnv: } # {op: Story.SELECT}
		level 2:  [QUERY] Story.select(:id) . where	{params: ActiveRecord, } # {returnv: } # {op: .SELECT}
		level 2:  [QUERY] self.results . select	{params: } # {returnv: } # {op: .SELECT}
		level 2: Vote . before_filter (params: ) # (returnv: )
		level 2: Vote . comment_votes_by_user_for_comment_ids_hash (params: user, self, ) # (returnv: votes)
			level 3:  [QUERY] self . where	{params: user_id, comment_ids, } # {returnv: votes} # {op: Vote.SELECT}
		level 2:  [QUERY] self.results . select	{params: } # {returnv: } # {op: .SELECT}
		level 2: Vote . story_votes_by_user_for_story_ids_hash (params: user, self, ) # (returnv: votes)
			level 3:  [QUERY] self . where	{params: user_id, nil, story_ids, } # {returnv: votes} # {op: Vote.SELECT}
	level 1: Search . to_url_params (params: ) # (returnv: )
		level 2:  [QUERY] [ :q, :what, :order ].map{|p| "#{p}=#{CGI.escape(self.send(p).to_s)}"      } . join	{params: } # {returnv: } # {op: .JOIN}
