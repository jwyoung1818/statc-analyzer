level 0: HomeController . before_filter (params: ) # (returnv: )
	level 1: ApplicationController . before_filter (params: ) # (returnv: )
		level 2: ApplicationController . authenticate_user (params: ) # (returnv: )
			level 3:  [QUERY] User . where	{params: session[:u], } # {returnv: true} # {op: User.SELECT}
			level 3:  [QUERY] User.where(:session_token => session[:u].to_s) . first	{params: } # {returnv: user} # {op: .SELECT}
			level 3: User . before_filter (params: ) # (returnv: )
			level 3: User . is_active? (params: ) # (returnv: true)
				level 4: User . is_banned? (params: ) # (returnv: )
			level 1: ApplicationController . increase_traffic_counter (params: ) # (returnv: )
		level 2: ApplicationController . user_is_spider? (params: ) # (returnv: true)
		level 2: Keystore . before_filter (params: ) # (returnv: )
		level 2: Keystore . find_or_create_key_for_update (params: now_i, ) # (returnv: date_kv)
			level 3:  [QUERY] self . lock	{params: true, } # {returnv: } # {op: .TXN}
			level 3:  [QUERY] self.lock(true) . where	{params: key, } # {returnv: } # {op: .SELECT}
			level 3:  [QUERY] self.lock(true).where(:key => key) . first	{params: } # {returnv: kv} # {op: .SELECT}
=====transaction begin=====
			level 3:  [QUERY] kv . save!	{params: } # {returnv: } # {op: .INSERT}
=====transaction end=====
	level 1: ApplicationController . find_user_from_rss_token (params: ) # (returnv: )
		level 2:  [QUERY] User . where	{params: params[:token], } # {returnv: } # {op: User.SELECT}
		level 2:  [QUERY] User.where(:rss_token => params[:token].to_s) . first	{params: } # {returnv: @user} # {op: .SELECT}
	level 0: HomeController . tagged (params: ) # (returnv: )
	level 1:  [QUERY] Tag . where	{params: params[:tag], } # {returnv: } # {op: Tag.SELECT}
	level 1:  [QUERY] Tag.where(:tag => params[:tag]) . first!	{params: } # {returnv: @tag} # {op: .SELECT}
	level 1: HomeController . get_from_cache (params: ) # (returnv: )
		level 2: ApplicationController . tags_filtered_by_cookie (params: ) # (returnv: true)
			level 3:  [QUERY] Tag . where	{params: cookies[TAG_FILTER_COOKIE], } # {returnv: @_tags_filtered} # {op: Tag.SELECT}
		level 2:  [QUERY] opts.merge(page: page).sort.map{|k,v| "#{k}=#{v.to_param}"        } . join	{params: } # {returnv: key} # {op: .JOIN}
	level 1: Story . before_filter (params: ) # (returnv: )
	level 1: Story . score (params: ) # (returnv: )
	level 1: Story . can_be_seen_by_user? (params: @user, ) # (returnv: true)
	level 1: Story . url_or_comments_path (params: ) # (returnv: )
		level 2: Story . comments_path (params: ) # (returnv: )
			level 3: Story . title_as_url (params: ) # (returnv: )
	level 1: Story . is_gone? (params: ) # (returnv: true)
	level 1: Story . sorted_taggings (params: ) # (returnv: )
	level 1: Tag . before_filter (params: ) # (returnv: )
	level 1: Tag . css_class (params: ) # (returnv: )
	level 1: Story . domain (params: ) # (returnv: true)
	level 1: Story . domain_search_url (params: ) # (returnv: )
	level 1: User . avatar_url (params: ) # (returnv: )
	level 1: Story . html_class_for_user (params: ) # (returnv: )
		level 2: User . is_new? (params: ) # (returnv: true)
		level 2:  [QUERY] c . join	{params: } # {returnv: } # {op: .JOIN}
	level 1: Story . description_or_story_cache (params: ) # (returnv: sc)
	level 1: Story . is_editable_by_user? (params: @user, ) # (returnv: true)
	level 1: Story . is_undeletable_by_user? (params: @user, ) # (returnv: true)
	level 1:  [QUERY] @user . try	{params: } # {returnv: true} # {op: User.SELECT}
	level 1:  [QUERY] @user . try	{params: } # {returnv: true} # {op: User.SELECT}
	level 1: User . can_downvote? (params: ) # (returnv: true)
		level 2:  [QUERY] obj.current_vote . try	{params: } # {returnv: true} # {op: .SELECT}
	level 1: Story . hider_count (params: ) # (returnv: true)
		level 2:  [QUERY] HiddenStory . where	{params: self, } # {returnv: } # {op: HiddenStory.SELECT}
		level 2:  [QUERY] HiddenStory.where(:story_id => self.id) . count	{params: } # {returnv: @hider_count} # {op: .SELECT}
	level 1: Story . vote_summary_for (params: @user, ) # (returnv: )
		level 2:  [QUERY] Vote.where(:story_id => self.id, :comment_id => nil) . where	{params: } # {returnv: } # {op: .SELECT}
		level 2:  [QUERY] Vote.where(:story_id => self.id, :comment_id => nil) . where	{params: } # {returnv: } # {op: .SELECT}
		level 2:  [QUERY] r_counts.keys.sort.map{|k|      if k == ""        "+#{r_counts[k]}"      else        "#{r_counts[k]} " +          (Vote::STORY_REASONS[k] || Vote::OLD_STORY_REASONS[k] || k) +          (user && user.is_moderator?? " (#{r_whos[k].join(", ")})" : "")      end    } . join	{params: } # {returnv: } # {op: .JOIN}
		level 2:  [QUERY] r_counts.keys.sort.map{|k|      if k == ""        "+#{r_counts[k]}"      else        "#{r_counts[k]} " +          (Vote::STORY_REASONS[k] || Vote::OLD_STORY_REASONS[k] || k) +          (user && user.is_moderator?? " (#{r_whos[k].join(", ")})" : "")      end    } . join	{params: } # {returnv: } # {op: .JOIN}
	level 1: Story . url_or_comments_url (params: ) # (returnv: )
		level 2: Story . comments_url (params: ) # (returnv: )
	level 1: Story . short_id_url (params: ) # (returnv: )
