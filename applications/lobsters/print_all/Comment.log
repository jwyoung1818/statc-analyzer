dir = ../applications/lobsters/
Super cannot find upper: User . as_json
######## BEGIN ########
Class: Comment
Method valid?:
	 ** variables: {DOWNVOTABLE_DAYS, MAX_EDIT_MINS, m, }
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
Method new:
	 ** variables: {}
Method arrange_for_user:
	 ** variables: {parents, ordered, ancestors, subtree, node, children, node.indent_level, }
	 
	 ++ CALL DB QUERY: self . order (params: , , returnv: )
	 
	 
	 
	 
	 
	 
	 
	 
	 
Method regenerate_markdown:
	 ** variables: {Comment.record_timestamps, c.markeddown_comment, }
	 
	 
	 
	 ++ CALL DB QUERY: c . save (params: false, , returnv: )
Method score_sql:
	 ** variables: {}
	 
	 
Method as_json:
	 ** variables: {h, js, js[k, js[k.keys.first, }
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 ++ CALL DB QUERY: k.values . first (params: , returnv: true)
	 
	 ++ CALL DB QUERY: k.keys . first (params: , returnv: )
	 
	 
	 ++ CALL DB QUERY: k.values . first (params: , returnv: )
	 
	 ++ CALL DB QUERY: k.keys . first (params: , returnv: )
	 
	 ++ CALL DB QUERY: k.values . first (params: , returnv: js[k.keys.first)
	 
Method assign_initial_confidence:
	 ** variables: {self.confidence, }
	 
Method assign_short_id_and_upvote:
	 ** variables: {self.short_id, self.upvotes, }
	 
	 
	 
Method assign_thread_id:
	 ** variables: {self.thread_id, }
	 
	 
	 
	 
	 
Method calculated_confidence:
	 ** variables: {n, z, p, left, right, under, }
	 
	 
	 
	 
	 
	 
Method comment=:
	 ** variables: {self[:comment, self.markeddown_comment, }
	 
	 
	 
Method delete_for_user:
	 ** variables: {Comment.record_timestamps, self.is_deleted, self.is_moderated, m, m.comment_id, m.moderator_user_id, m.action, }
	 
	 
	 
	 
	 
	 
	 ++ CALL DB QUERY: m . save (params: , returnv: )
	 ++ CALL DB QUERY: self . save (params: false, , returnv: )
	 
	 
Method deliver_mention_notifications:
	 ** variables: {u, }
	 
	 ++ CALL DB QUERY: self.plaintext_comment.scan(/\B\@([\w\-]+)/).flatten . uniq (params: , returnv: )
	 
	 
	 
	 ++ CALL DB QUERY: User.where(:username => mention) . first (params: , returnv: u)
	 ++ CALL DB QUERY: User . where (params: mention, , returnv: true)
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
Method deliver_reply_notifications:
	 ** variables: {u, }
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
Method generated_markeddown_comment:
	 ** variables: {}
	 
	 
Method give_upvote_or_downvote_and_recalculate_confidence!:
	 ** variables: {self.upvotes, self.downvotes, }
	 
	 
	 ++ CALL DB QUERY: Comment.connection . execute (params: Comment, , returnv: )
	 
	 
	 
	 
	 
	 
	 
	 
	 
Method gone_text:
	 ** variables: {}
	 
	 
	 
	 
	 
	 
	 
Method has_been_edited?:
	 ** variables: {}
	 
	 
	 
	 
Method is_deletable_by_user?:
	 ** variables: {}
	 
	 
	 
Method is_downvotable?:
	 ** variables: {}
	 
	 
	 
	 
Method is_editable_by_user?:
	 ** variables: {}
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
Method is_gone?:
	 ** variables: {}
	 
	 
Method is_undeletable_by_user?:
	 ** variables: {}
	 
	 
	 
	 
Method log_to_countinual:
	 ** variables: {}
	 
	 
	 
Method mark_submitter:
	 ** variables: {}
	 
	 
Method mailing_list_message_id:
	 ** variables: {}
	 
	 
	 
	 
	 
Method path:
	 ** variables: {}
	 
	 
	 
	 
Method plaintext_comment:
	 ** variables: {}
	 
Method record_initial_upvote:
	 ** variables: {}
	 
	 
	 
	 
	 
	 
Method score:
	 ** variables: {}
	 
	 
Method short_id_path:
	 ** variables: {}
	 
	 
	 
	 
Method short_id_url:
	 ** variables: {}
	 
	 
	 
	 
Method to_param:
	 ** variables: {}
	 
Method unassign_votes:
	 ** variables: {}
	 
	 
Method url:
	 ** variables: {}
	 
	 
	 
	 
Method vote_summary:
	 ** variables: {r_counts, r_counts[v.reason.to_s, }
	 
	 ++ CALL DB QUERY: Vote . where (params: self, , returnv: )
	 
	 
	 
	 
	 
	 
	 ++ CALL DB QUERY: r_counts.keys.sort.map{|k|      k == "" ? "+#{r_counts[k]}" : "#{r_counts[k]} #{Vote::COMMENT_REASONS[k]}"    } . join (params: , , returnv: )
	 
	 
	 
Method undelete_for_user:
	 ** variables: {Comment.record_timestamps, self.is_deleted, self.is_moderated, m, m.comment_id, m.moderator_user_id, m.action, }
	 
	 
	 
	 
	 
	 
	 ++ CALL DB QUERY: m . save (params: , returnv: )
	 ++ CALL DB QUERY: self . save (params: false, , returnv: )
	 
	 
